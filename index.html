<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus Urbano A Coru√±a</title>
    <meta name="description" content="Informaci√≥n de rutas de autob√∫s urbano de A Coru√±a en tiempo real">
    <meta name="theme-color" content="#2196F3">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            min-height: 100vh;
        }
        
        h1 {
            color: #2196F3;
            font-size: 28px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .route-selector {
            margin-bottom: 20px;
            padding: 20px;
            background-color: #e3f2fd;
            border-radius: 8px;
            border: 2px solid #2196F3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }
        
        .route-selector label {
            display: block;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #1976D2;
            text-align: center;
        }
        
        .route-selector select {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid #2196F3;
            border-radius: 8px;
            background-color: white;
            font-weight: 500;
            cursor: pointer;
        }
        
        .route-selector select:focus {
            outline: none;
            border-color: #1976D2;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
        }
        
        /* Estilos para el interruptor de direcci√≥n */
        .direction-toggle {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f0f8f0;
            border-radius: 8px;
            border: 2px solid #4CAF50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
        }
        
        .direction-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 20px;
            border: none;
            background-color: transparent;
            color: #4CAF50;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 6px;
            flex: 1;
            text-align: center;
            margin: 0 5px;
        }
        
        .direction-btn.active {
            background-color: #4CAF50;
            color: white;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }
        
        .direction-btn:hover:not(.active) {
            background-color: #e8f5e9;
            transform: translateY(-1px);
        }
        
        .direction-icon {
            font-size: 32px;
            margin-bottom: 8px;
            line-height: 1;
        }
        
        .direction-text {
            font-size: 14px;
            font-weight: bold;
            line-height: 1.2;
        }
        
        .destination-selector {
            margin-top: 15px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 8px;
            border: 2px solid #2196F3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }
        
        .destination-selector label {
            display: block;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #1976D2;
            text-align: center;
        }
        
        .destination-selector select {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid #2196F3;
            border-radius: 8px;
            background-color: white;
            font-weight: 500;
            cursor: pointer;
        }
        
        .destination-selector select:focus {
            outline: none;
            border-color: #1976D2;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
        }
        
        #map {
            height: 400px;
            width: 100%;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }
        
        .section h2 {
            color: #2196F3;
            font-size: 22px;
            margin-bottom: 15px;
            border-bottom: 2px solid #2196F3;
            padding-bottom: 5px;
        }
        
        .arrival-info {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .arrival-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: white;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .arrival-time {
            font-size: 24px;
            font-weight: bold;
            color: #1976D2;
        }
        
        .arrival-line {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .stops-list {
            list-style: none;
        }
        
        .stop-item {
            padding: 12px;
            margin-bottom: 8px;
            background-color: white;
            border-radius: 5px;
            border-left: 4px solid #2196F3;
            font-size: 16px;
        }
        
        .stop-item.origin {
            border-left-color: #4CAF50;
            background-color: #e8f5e9;
        }
        
        .stop-item.destination {
            border-left-color: #f44336;
            background-color: #ffebee;
        }
        
        /* Estilos para m√∫ltiples rutas */
        .route-header {
            margin-bottom: 15px;
        }
        
        .route-section {
            margin-bottom: 10px;
        }
        
        .line-indicator {
            background-color: #2196F3;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .stop-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .stop-number {
            font-weight: bold;
            color: #2196F3;
            margin-right: 10px;
        }
        
        .stop-name {
            flex: 1;
        }
        

        
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 18px;
            color: #666;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin: 10px 0;
        }
        
        .error {
            background-color: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .btn-update {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            display: block;
            margin: 20px auto;
        }
        
        .btn-update:hover {
            background-color: #1976D2;
        }
        
        .btn-update:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        #btnClearCache:hover {
            background-color: #d32f2f !important;
        }
        
        .update-time {
            text-align: center;
            font-size: 16px;
            color: #333;
            margin-top: 15px;
            padding: 12px;
            background-color: #e3f2fd;
            border-radius: 8px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            font-weight: 500;
            line-height: 1.4;
        }
        
        @media print {
            .btn-update,
            .route-selector,
            .arrival-info {
                display: none;
            }
            
            #map {
                height: 300px;
            }
            
            .container {
                padding: 10px;
            }
        }
        
        /* Ocultar botones de actualizaci√≥n */
        .btn-update,
        #btnClearCache {
            display: none !important;
        }
        
        /* Estilos para pie de p√°gina unificado */
        .footer {
            margin-top: 40px;
            padding: 15px;
            text-align: center;
            border-top: 1px solid #eee;
            background-color: #fafafa;
            border-radius: 8px;
        }
        
        .footer-section {
            margin-bottom: 8px;
        }
        
        .footer-section:last-child {
            margin-bottom: 0;
        }
        
        .footer-title {
            font-size: 9px;
            color: #ccc;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .footer-links {
            font-size: 8px;
            color: #ddd;
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .footer-links a {
            color: #ddd !important;
            text-decoration: none;
            padding: 2px 4px;
            border-radius: 2px;
            transition: all 0.2s ease;
        }
        
        .footer-links a:hover {
            color: #999 !important;
            background-color: #f0f0f0;
        }
        
        .footer-project-title {
            font-size: 9px;
            font-weight: normal;
            color: #ccc;
            margin-bottom: 4px;
        }
        
        .footer-project-details {
            font-size: 7px;
            color: #ddd;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .footer-project-details span {
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .footer-project-details a {
            color: #ddd;
            text-decoration: none;
            font-weight: normal;
        }
        
        .footer-project-details a:hover {
            color: #999;
        }
        
        .footer-divider {
            width: 80%;
            height: 1px;
            background-color: #eee;
            margin: 8px auto;
        }
        
        @media (max-width: 600px) {
            .footer-project-details {
                flex-direction: column;
                gap: 3px;
            }
            
            .footer-links {
                gap: 6px;
            }
        }
        
        /* Estilos globales para tarjetas (aplicado en m√≥vil y desktop) */
                    .schedule-cards {
                display: block;
            }
            
            /* Sin restricciones de altura en m√≥viles */
            .info-content.expanded {
                max-height: none;
            }
            
            .line-section {
                margin: 8px;
                padding: 10px;
            }
            
            .line-subsection {
                margin: 6px 0;
                padding: 6px;
            }
        
        /* Ocultar tabla tradicional globalmente */
        .schedule-table {
            display: none;
        }
        
        .schedule-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .schedule-card-header {
            background-color: #2196F3;
            color: white;
            padding: 8px 12px;
            border-radius: 6px 6px 0 0;
            margin: -12px -12px 8px -12px;
            font-weight: bold;
            text-align: center;
        }
        
        .schedule-card-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
            font-size: 14px;
        }
        
        .schedule-card-row:last-child {
            border-bottom: none;
        }
        
        .schedule-card-label {
            font-weight: bold;
            color: #666;
            min-width: 80px;
            font-size: 14px;
        }
        
        .schedule-card-value {
            color: #333;
            text-align: right;
            flex: 1;
            margin-left: 10px;
            font-size: 14px;
        }
        
        /* Estilos para la nueva secci√≥n de informaci√≥n colapsable */
        .info-section {
            margin-bottom: 20px;
        }
        
        .info-header {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            padding: 15px;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }
        
        .info-header:hover {
            background: linear-gradient(135deg, #1976D2, #1565C0);
        }
        
        .info-toggle {
            font-size: 18px;
            transition: transform 0.3s ease;
        }
        
        .info-content {
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease;
        }
        
        .info-content.expanded {
            max-height: none;
            overflow: visible;
        }
        
        .line-section {
            margin: 10px;
            padding: 12px;
            background: #f9f9f9;
            border-radius: 8px;
        }
        
        .line-title {
            font-weight: bold;
            color: #1976D2;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .line-subsection {
            margin: 8px 0;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        .subsection-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
            font-size: 16px;
        }
        
        .itinerary-stops {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            font-size: 15px;
            color: #666;
            margin-top: 10px;
            padding: 8px;
            background-color: white;
            border-radius: 4px;
        }
        
        .stop-item-itinerary {
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
            color: #666;
        }
        
        .arrow-separator {
            color: #2196F3;
            font-weight: bold;
        }
        
        .next-schedules {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
            padding: 8px;
            background-color: white;
            border-radius: 4px;
        }
        
        .schedule-time {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            color: #666;
        }
        
        .schedule-time.past {
            background: #ccc;
            color: #666;
        }
        


        @media (max-width: 600px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            #map {
                height: 300px;
            }
            
            .direction-toggle {
                flex-direction: column;
                gap: 10px;
            }
            
            .direction-btn {
                margin: 0;
                padding: 15px 10px;
            }
            
            .direction-text {
                font-size: 16px;
            }
            
            .destination-selector select {
                font-size: 16px;
                padding: 12px;
            }
            
            /* Contenedor con scroll horizontal para tablas */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                margin: 0 -10px;
                padding: 0 10px;
            }
        }

        /* Estilos para el interruptor de direcci√≥n */
        .direction-toggle {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f0f8f0; /* Verde claro para el interruptor */
            border-radius: 5px;
            border: 1px solid #4CAF50; /* Borde verde */
        }

        .direction-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 15px;
            border: none;
            background-color: #f0f8f0; /* Fondo verde claro */
            color: #4CAF50; /* Texto verde */
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            border-radius: 5px;
            flex: 1;
            text-align: center;
        }

        .direction-btn.active {
            background-color: #4CAF50;
            color: white;
        }

        .direction-btn:hover:not(.active) {
            background-color: #e8f5e9;
        }

        .direction-icon {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .destination-selector {
            margin-top: 15px;
            padding: 10px;
            background-color: #e3f2fd;
            border-radius: 8px;
            border: 2px solid #2196F3;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.2);
        }

        .destination-selector label {
            display: block;
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #1976D2;
            text-align: center;
        }

        .destination-selector select {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            border: 2px solid #2196F3;
            border-radius: 8px;
            background-color: white;
            font-weight: 500;
            cursor: pointer;
        }

        .destination-selector select:focus {
            outline: none;
            border-color: #1976D2;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Rutas habituales del bus de A Coru√±a</h1>
        
        <div class="route-selector">
            <label for="directionToggle"><img src="icon-192.png" alt="Icono de autob√∫s" style="height: 24px; vertical-align: middle; margin-right: 8px;"> ¬øA d√≥nde vas?</label>
            
            <!-- Interruptor principal -->
            <div class="direction-toggle">
                <button id="idaBtn" class="direction-btn active" onclick="selectDirection('ida')">
                    <span class="direction-icon">üè†‚û°Ô∏è</span>
                    <span class="direction-text">Ida desde casa</span>
                </button>
                <button id="vueltaBtn" class="direction-btn" onclick="selectDirection('vuelta')">
                    <span class="direction-icon">üè†‚¨ÖÔ∏è</span>
                    <span class="direction-text">Vuelta hacia casa</span>
                </button>
            </div>
            
            <!-- Selector de destino/origen -->
            <div id="destinationSelector" class="destination-selector">
                <label for="destinationSelect">üìç ¬øD√≥nde quieres ir?</label>
                <select id="destinationSelect">
                    <option value="loading">Cargando destinos...</option>
                </select>
            </div>
        </div>
        
        <div id="arrivalInfo" class="arrival-info section">
            <h2>‚è±Ô∏è Pr√≥ximos buses en E.Glez.L√≥pez, M.Aza√±a (Parada 42)</h2>

            <div id="arrivalsList">
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üöå</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Cargando tiempos de llegada...</div>
                        <div style="font-size: 14px; color: #999;">Conectando con el servicio en tiempo real</div>
                    </div>
                </div>
            </div>
            <div class="update-time" id="updateTime"></div>
        </div>
        
        <div id="map"></div>
        
        <div class="section">
            <h2>üìç Paradas del recorrido</h2>
            <ul id="stopsList" class="stops-list">
                <li class="loading">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 20px; margin-bottom: 8px;">üìç</div>
                        <div style="font-size: 16px; color: #666;">Cargando paradas...</div>
                    </div>
                </li>
            </ul>
        </div>
        
        <div class="section">
            <div id="scheduleInfo">
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚è≥</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Cargando informaci√≥n...</div>
                        <div style="font-size: 14px; color: #999;">Obteniendo datos actualizados</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Pie de p√°gina unificado -->
        <div class="footer">
            <div class="footer-section">
                <div class="footer-title">Funciones de mantenimiento</div>
                <div class="footer-links">
                    <a href="#" onclick="updateArrivalTime(); return false;">Actualizar</a>
                    <a href="#" onclick="reloadEverything(); return false;">Recargar</a>
                    <a href="#" onclick="showCacheStats(); return false;">Cach√©</a>
                    <a href="https://github.com/cjescudero/BusCoruna" target="_blank" rel="noopener">GitHub</a>
                </div>
            </div>
            
            <div class="footer-divider"></div>
            
            <div class="footer-section">
                <div class="footer-project-title">üöå Bus Coru√±a - Aplicaci√≥n Simple</div>
                <div class="footer-project-details">
                    <span>üìù Licencia MIT</span>
                    <span>üë§ <a href="https://github.com/cjescudero" target="_blank" rel="noopener">@cjescudero</a></span>
                    <span>üîó <a href="https://github.com/cjescudero/BusCoruna" target="_blank" rel="noopener">Ver c√≥digo</a></span>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    
    <script>
        // Configuraci√≥n de la aplicaci√≥n
        const BACKEND_API = window.location.origin + '/buscoruna/api';
        let map;
        let routeLayer;
        let linesData = {};
        let stopsData = {};
        

        
        // Variables globales
        let routesConfig = {};
        let currentRoute = {};
        let currentDirection = 'ida'; // 'ida' o 'vuelta'
        let userLocation = null; // Ubicaci√≥n del usuario
        let userLocationMarker = null; // Marcador de ubicaci√≥n del usuario en el mapa
        let gpsAvailable = false; // Estado de disponibilidad de GPS
        let autoDirectionEnabled = true; // Control de detecci√≥n autom√°tica
        
        // Sistema de cach√© localStorage
        const CACHE_KEYS = {
            GENERAL_DATA: 'busCoruna_generalData',
            LINE_DATA: 'busCoruna_lineData_',
            SCHEDULE_DATA: 'busCoruna_scheduleData_',
            CACHE_VERSION: 'busCoruna_cacheVersion'
        };
        
        const CACHE_VERSION = '1.0.0';
        const CACHE_TTL = {
            STATIC: 7 * 24 * 60 * 60 * 1000, // 7 d√≠as para datos est√°ticos
            DAILY: 24 * 60 * 60 * 1000,      // 24 horas para horarios
            REALTIME: 2 * 60 * 1000          // 2 minutos para tiempo real
        };
        
        // Funciones utilitarias de cach√© localStorage
        function setCache(key, data, ttl) {
            try {
                const cacheData = {
                    data: data,
                    timestamp: Date.now(),
                    ttl: ttl,
                    version: CACHE_VERSION
                };
                localStorage.setItem(key, JSON.stringify(cacheData));
                console.log(`üíæ [localStorage] Guardado: ${key}`);
            } catch (error) {
                console.warn(`‚ö†Ô∏è [localStorage] Error guardando ${key}:`, error);
            }
        }
        
        function getCache(key) {
            try {
                const cached = localStorage.getItem(key);
                if (!cached) return null;
                
                const cacheData = JSON.parse(cached);
                
                // Verificar versi√≥n
                if (cacheData.version !== CACHE_VERSION) {
                    console.log(`üîÑ [localStorage] Versi√≥n obsoleta para ${key}, eliminando`);
                    localStorage.removeItem(key);
                    return null;
                }
                
                // Verificar TTL
                const age = Date.now() - cacheData.timestamp;
                if (age > cacheData.ttl) {
                    console.log(`‚è∞ [localStorage] Cach√© expirado para ${key}, eliminando`);
                    localStorage.removeItem(key);
                    return null;
                }
                
                console.log(`üéØ [localStorage] Hit: ${key} (edad: ${Math.round(age/1000/60)} min)`);
                return cacheData.data;
            } catch (error) {
                console.warn(`‚ö†Ô∏è [localStorage] Error leyendo ${key}:`, error);
                localStorage.removeItem(key);
                return null;
            }
        }
        
        function clearCache(pattern = null) {
            try {
                if (pattern) {
                    // Limpiar solo claves que coincidan con el patr√≥n
                    Object.keys(localStorage).forEach(key => {
                        if (key.includes(pattern)) {
                            localStorage.removeItem(key);
                            console.log(`üóëÔ∏è [localStorage] Eliminado: ${key}`);
                        }
                    });
                } else {
                    // Limpiar todas las claves de la aplicaci√≥n
                    Object.values(CACHE_KEYS).forEach(key => {
                        if (typeof key === 'string') {
                            localStorage.removeItem(key);
                        } else {
                            // Para claves con prefijos (como LINE_DATA_)
                            Object.keys(localStorage).forEach(storageKey => {
                                if (storageKey.startsWith(key)) {
                                    localStorage.removeItem(storageKey);
                                    console.log(`üóëÔ∏è [localStorage] Eliminado: ${storageKey}`);
                                }
                            });
                        }
                    });
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è [localStorage] Error limpiando cach√©:', error);
            }
        }
        
        // ========= FUNCIONES DE GEOLOCALIZACI√ìN =========
        
        // Calcular distancia entre dos coordenadas usando f√≥rmula haversine
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radio de la Tierra en kil√≥metros
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            const distance = R * c * 1000; // Convertir a metros
            return distance;
        }
        
        // Obtener ubicaci√≥n del usuario
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    gpsAvailable = false;
                    updateGPSIcon();
                    reject(new Error('Geolocalizaci√≥n no soportada por el navegador'));
                    return;
                }
                
                console.log('üó∫Ô∏è Solicitando ubicaci√≥n del usuario...');
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const location = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy
                        };
                        console.log('üìç Ubicaci√≥n obtenida:', location);
                        gpsAvailable = true;
                        updateGPSIcon();
                        resolve(location);
                    },
                    (error) => {
                        console.warn('‚ö†Ô∏è Error obteniendo ubicaci√≥n:', error.message);
                        gpsAvailable = false;
                        updateGPSIcon();
                        reject(error);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000 // 5 minutos
                    }
                );
            });
        }
        
        // Mostrar ubicaci√≥n del usuario en el mapa
        function showUserLocationOnMap() {
            if (!userLocation || !map) {
                console.log('‚ö†Ô∏è No se puede mostrar ubicaci√≥n: faltan datos de ubicaci√≥n o mapa');
                return;
            }
            
            // Remover marcador anterior si existe
            if (userLocationMarker) {
                map.removeLayer(userLocationMarker);
                userLocationMarker = null;
            }
            
            // Crear icono de persona para el usuario
            const userIcon = L.divIcon({
                html: `<div style="background-color: #2196F3; color: white; padding: 8px; border-radius: 50%; font-weight: bold; width: 35px; height: 35px; display: flex; align-items: center; justify-content: center; border: 3px solid #fff; box-shadow: 0 2px 8px rgba(33, 150, 243, 0.4);">üë§</div>`,
                iconSize: [35, 35],
                className: 'user-location-icon'
            });
            
            // Crear marcador de ubicaci√≥n del usuario
            userLocationMarker = L.marker([userLocation.latitude, userLocation.longitude], { 
                icon: userIcon,
                zIndexOffset: 1000 // Asegurar que est√© por encima de otros marcadores
            }).addTo(map);
            
            // Agregar popup con informaci√≥n de precisi√≥n
            const accuracyText = userLocation.accuracy ? `Precisi√≥n: ¬±${Math.round(userLocation.accuracy)}m` : 'Ubicaci√≥n aproximada';
            userLocationMarker.bindPopup(`<b>üìç Tu ubicaci√≥n</b><br><small>${accuracyText}</small>`);
            
            console.log('üìç Marcador de ubicaci√≥n del usuario agregado al mapa');
        }
        
        // Ocultar ubicaci√≥n del usuario del mapa
        function hideUserLocationFromMap() {
            if (userLocationMarker && map) {
                map.removeLayer(userLocationMarker);
                userLocationMarker = null;
                console.log('üìç Marcador de ubicaci√≥n del usuario removido del mapa');
            }
        }
        
        // Actualizar icono de GPS en la cabecera
        function updateGPSIcon() {
            const label = document.querySelector('label[for="directionToggle"]');
            if (!label) return;
            
            // Buscar o crear el icono de GPS
            let gpsIcon = label.querySelector('.gps-icon');
            if (!gpsIcon) {
                gpsIcon = document.createElement('span');
                gpsIcon.className = 'gps-icon';
                gpsIcon.style.cssText = 'margin-left: 8px; font-size: 16px; opacity: 0.7;';
                label.appendChild(gpsIcon);
            }
            
            if (gpsAvailable && userLocation) {
                gpsIcon.textContent = 'üõ∞Ô∏è';
                gpsIcon.style.opacity = '1';
                gpsIcon.style.color = '#4CAF50';
            } else {
                gpsIcon.textContent = '';
                gpsIcon.style.opacity = '0';
            }
        }
        
        // Actualizar ubicaci√≥n del usuario en el mapa
        function updateUserLocationOnMap() {
            if (userLocation && map && gpsAvailable) {
                showUserLocationOnMap();
            } else {
                hideUserLocationFromMap();
            }
        }
        
        // Detectar direcci√≥n autom√°ticamente bas√°ndose en paradas m√°s cercanas (con notificaci√≥n)
        async function detectAutoDirection() {
            if (!autoDirectionEnabled) {
                console.log('üîÑ Detecci√≥n autom√°tica deshabilitada');
                return false;
            }
            
            try {
                // Obtener ubicaci√≥n del usuario
                userLocation = await getUserLocation();
                
                // Mostrar ubicaci√≥n del usuario en el mapa autom√°ticamente
                showUserLocationOnMap();
                
                // Usar la misma l√≥gica que la funci√≥n autom√°tica de rutas
                const targetLineIds = ['300', '301', '1200', '1400']; // L√≠neas 3, 3A, 12, 14
                const excludedStops = [42, 43, 44, 87, 88, 89, 90, 358, 553];
                
                // Encontrar la parada m√°s cercana de las l√≠neas objetivo
                const candidateStops = {};
                
                Object.values(stopsData).forEach(stop => {
                    if (!stop.enlaces) return;
                    
                    // Verificar si alguna de las l√≠neas objetivo pasa por esta parada
                    const matchingLines = [];
                    stop.enlaces.forEach(lineId => {
                        if (targetLineIds.includes(lineId.toString())) {
                            matchingLines.push(lineId.toString());
                        }
                    });
                    
                    if (matchingLines.length > 0) {
                        const distance = calculateDistance(
                            userLocation.latitude,
                            userLocation.longitude,
                            stop.posy,
                            stop.posx
                        );
                        
                        candidateStops[stop.id] = {
                            stopId: stop.id,
                            stopName: stop.nombre,
                            distance: distance,
                            lines: matchingLines
                        };
                    }
                });
                
                if (Object.keys(candidateStops).length === 0) {
                    console.warn('‚ö†Ô∏è No se encontraron paradas de l√≠neas objetivo para detecci√≥n autom√°tica');
                    return false;
                }
                
                // Encontrar la parada m√°s cercana
                let nearestStop = null;
                let minDistance = Infinity;
                
                Object.values(candidateStops).forEach(stop => {
                    if (stop.distance < minDistance) {
                        minDistance = stop.distance;
                        nearestStop = stop;
                    }
                });
                
                if (!nearestStop) {
                    console.warn('‚ö†Ô∏è No se pudo determinar parada m√°s cercana');
                    return false;
                }
                
                // Determinar direcci√≥n seg√∫n si la parada m√°s cercana est√° excluida
                const isNearHome = excludedStops.includes(parseInt(nearestStop.stopId));
                const detectedDirection = isNearHome ? 'ida' : 'vuelta';
                
                console.log(`üìç Parada m√°s cercana: ${nearestStop.stopName} (${nearestStop.stopId}) - ${Math.round(nearestStop.distance)}m`);
                console.log(`üéØ Direcci√≥n detectada autom√°ticamente: ${detectedDirection.toUpperCase()} (${isNearHome ? 'cerca de casa' : 'lejos de casa'})`);
                
                // Aplicar la direcci√≥n detectada
                selectDirection(detectedDirection);
                
                // Actualizar icono de ubicaci√≥n
                updateLocationIcon(true, Math.round(nearestStop.distance));
                
                // Mostrar notificaci√≥n al usuario
                showLocationNotification(isNearHome, Math.round(nearestStop.distance), nearestStop.stopName);
                
                return true;
                
            } catch (error) {
                let errorMessage = 'Error desconocido';
                let disableAuto = false;
                
                if (error.code === 1) { // PERMISSION_DENIED
                    errorMessage = 'Permisos de ubicaci√≥n denegados';
                    disableAuto = true;
                } else if (error.code === 2) { // POSITION_UNAVAILABLE
                    errorMessage = 'Ubicaci√≥n no disponible';
                } else if (error.code === 3) { // TIMEOUT
                    errorMessage = 'Tiempo de espera agotado';
                } else if (error.message.includes('Geolocalizaci√≥n no soportada')) {
                    errorMessage = 'Geolocalizaci√≥n no soportada';
                    disableAuto = true;
                } else {
                    errorMessage = error.message;
                }
                
                console.warn('‚ö†Ô∏è No se pudo detectar direcci√≥n autom√°ticamente:', errorMessage);
                
                // Si es un error permanente, deshabilitar detecci√≥n autom√°tica
                if (disableAuto) {
                    autoDirectionEnabled = false;
                    const toggle = document.getElementById('autoDirectionToggle');
                    if (toggle) {
                        toggle.textContent = 'üìç Auto: OFF';
                        toggle.style.color = '#999';
                    }
                    
                    // Mostrar notificaci√≥n explicativa
                    showLocationErrorNotification(errorMessage);
                }
                
                return false;
            }
        }
        
        // Detectar direcci√≥n autom√°ticamente sin mostrar notificaci√≥n
        async function detectAutoDirectionSilent() {
            if (!autoDirectionEnabled) {
                console.log('üîÑ Detecci√≥n autom√°tica deshabilitada');
                return false;
            }
            
            try {
                // Obtener ubicaci√≥n del usuario
                userLocation = await getUserLocation();
                
                // Mostrar ubicaci√≥n del usuario en el mapa autom√°ticamente
                showUserLocationOnMap();
                
                // Usar la misma l√≥gica que la funci√≥n autom√°tica de rutas
                const targetLineIds = ['300', '301', '1200', '1400']; // L√≠neas 3, 3A, 12, 14
                const excludedStops = [42, 43, 44, 87, 88, 89, 90, 358, 553];
                
                // Encontrar la parada m√°s cercana de las l√≠neas objetivo
                const candidateStops = {};
                
                Object.values(stopsData).forEach(stop => {
                    if (!stop.enlaces) return;
                    
                    // Verificar si alguna de las l√≠neas objetivo pasa por esta parada
                    const matchingLines = [];
                    stop.enlaces.forEach(lineId => {
                        if (targetLineIds.includes(lineId.toString())) {
                            matchingLines.push(lineId.toString());
                        }
                    });
                    
                    if (matchingLines.length > 0) {
                        const distance = calculateDistance(
                            userLocation.latitude,
                            userLocation.longitude,
                            stop.posy,
                            stop.posx
                        );
                        
                        candidateStops[stop.id] = {
                            stopId: stop.id,
                            stopName: stop.nombre,
                            distance: distance,
                            lines: matchingLines
                        };
                    }
                });
                
                if (Object.keys(candidateStops).length === 0) {
                    console.warn('‚ö†Ô∏è No se encontraron paradas de l√≠neas objetivo para detecci√≥n autom√°tica');
                    return false;
                }
                
                // Encontrar la parada m√°s cercana
                let nearestStop = null;
                let minDistance = Infinity;
                
                Object.values(candidateStops).forEach(stop => {
                    if (stop.distance < minDistance) {
                        minDistance = stop.distance;
                        nearestStop = stop;
                    }
                });
                
                if (!nearestStop) {
                    console.warn('‚ö†Ô∏è No se pudo determinar parada m√°s cercana');
                    return false;
                }
                
                // Determinar direcci√≥n seg√∫n si la parada m√°s cercana est√° excluida
                const isNearHome = excludedStops.includes(parseInt(nearestStop.stopId));
                const detectedDirection = isNearHome ? 'ida' : 'vuelta';
                
                console.log(`üìç Parada m√°s cercana: ${nearestStop.stopName} (${nearestStop.stopId}) - ${Math.round(nearestStop.distance)}m`);
                console.log(`üéØ Direcci√≥n detectada autom√°ticamente: ${detectedDirection.toUpperCase()} (${isNearHome ? 'cerca de casa' : 'lejos de casa'})`);
                
                // Aplicar la direcci√≥n detectada
                selectDirection(detectedDirection);
                
                // Actualizar icono de ubicaci√≥n sin mostrar notificaci√≥n
                updateLocationIcon(true, Math.round(nearestStop.distance));
                
                return true;
                
            } catch (error) {
                let errorMessage = 'Error desconocido';
                let disableAuto = false;
                
                if (error.code === 1) { // PERMISSION_DENIED
                    errorMessage = 'Permisos de ubicaci√≥n denegados';
                    disableAuto = true;
                } else if (error.code === 2) { // POSITION_UNAVAILABLE
                    errorMessage = 'Ubicaci√≥n no disponible';
                } else if (error.code === 3) { // TIMEOUT
                    errorMessage = 'Tiempo de espera agotado';
                } else if (error.message.includes('Geolocalizaci√≥n no soportada')) {
                    errorMessage = 'Geolocalizaci√≥n no soportada';
                    disableAuto = true;
                } else {
                    errorMessage = error.message;
                }
                
                console.warn('‚ö†Ô∏è No se pudo detectar direcci√≥n autom√°ticamente:', errorMessage);
                
                // Si es un error permanente, deshabilitar detecci√≥n autom√°tica
                if (disableAuto) {
                    autoDirectionEnabled = false;
                    const toggle = document.getElementById('autoDirectionToggle');
                    if (toggle) {
                        toggle.textContent = 'üìç Auto: OFF';
                        toggle.style.color = '#999';
                    }
                }
                
                return false;
            }
        }
        
        // Actualizar icono de ubicaci√≥n en el t√≠tulo
        function updateLocationIcon(isLocated, distance = null) {
            const label = document.querySelector('.route-selector label');
            if (!label) return;
            
            // Buscar o crear el icono de ubicaci√≥n
            let locationIcon = label.querySelector('.location-icon');
            if (!locationIcon) {
                locationIcon = document.createElement('span');
                locationIcon.className = 'location-icon';
                locationIcon.style.cssText = 'margin-left: 8px; font-size: 16px; opacity: 0.7;';
                label.appendChild(locationIcon);
            }
            
            if (isLocated && distance !== null) {
                locationIcon.textContent = `üìç ${distance}m`;
                locationIcon.style.opacity = '1';
                locationIcon.style.color = '#4CAF50';
            } else {
                locationIcon.textContent = '';
                locationIcon.style.opacity = '0';
            }
        }
        
        // Mostrar notificaci√≥n sobre la detecci√≥n autom√°tica
        function showLocationNotification(isNearHome, distance, stopName = '') {
            const notification = document.createElement('div');
            notification.className = 'location-notification';
            
            const locationText = stopName ? `${distance}m de ${stopName}` : `${distance}m`;
            
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">${isNearHome ? 'üè†' : 'üöå'}</span>
                    <span class="notification-text">
                        ${isNearHome 
                            ? `Est√°s cerca de casa (${locationText}). Seleccionado: IDA DESDE CASA` 
                            : `Parada m√°s cercana: ${locationText}. Seleccionado: VUELTA HACIA CASA`}
                    </span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            // A√±adir estilos si no existen
            if (!document.querySelector('#location-notification-styles')) {
                const styles = document.createElement('style');
                styles.id = 'location-notification-styles';
                styles.textContent = `
                    .location-notification {
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: linear-gradient(135deg, #4CAF50, #45a049);
                        color: white;
                        padding: 0;
                        border-radius: 12px;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.15);
                        z-index: 10000;
                        font-family: inherit;
                        max-width: 90vw;
                        animation: slideDown 0.3s ease-out;
                    }
                    
                    .notification-content {
                        display: flex;
                        align-items: center;
                        padding: 12px 16px;
                        gap: 10px;
                    }
                    
                    .notification-icon {
                        font-size: 20px;
                        flex-shrink: 0;
                    }
                    
                    .notification-text {
                        flex: 1;
                        font-size: 14px;
                        line-height: 1.4;
                    }
                    
                    .notification-close {
                        background: rgba(255,255,255,0.2);
                        border: none;
                        color: white;
                        font-size: 18px;
                        width: 28px;
                        height: 28px;
                        border-radius: 50%;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-shrink: 0;
                        transition: background-color 0.2s;
                    }
                    
                    .notification-close:hover {
                        background: rgba(255,255,255,0.3);
                    }
                    
                    @keyframes slideDown {
                        from {
                            opacity: 0;
                            transform: translateX(-50%) translateY(-20px);
                        }
                        to {
                            opacity: 1;
                            transform: translateX(-50%) translateY(0);
                        }
                    }
                    
                    @media (max-width: 480px) {
                        .location-notification {
                            left: 10px;
                            right: 10px;
                            transform: none;
                            max-width: none;
                        }
                        
                        .notification-text {
                            font-size: 13px;
                        }
                    }
                `;
                document.head.appendChild(styles);
            }
            
            document.body.appendChild(notification);
            
            // Auto-remover despu√©s de 8 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 8000);
        }
        
        // Mostrar notificaci√≥n de error de geolocalizaci√≥n
        function showLocationErrorNotification(errorMessage) {
            const notification = document.createElement('div');
            notification.className = 'location-notification error';
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">‚ö†Ô∏è</span>
                    <span class="notification-text">
                        Detecci√≥n autom√°tica deshabilitada: ${errorMessage}. 
                        Puedes seleccionar la direcci√≥n manualmente.
                    </span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            // A√±adir estilos para error si no existen
            if (!document.querySelector('#location-error-styles')) {
                const styles = document.createElement('style');
                styles.id = 'location-error-styles';
                styles.textContent = `
                    .location-notification.error {
                        background: linear-gradient(135deg, #f44336, #d32f2f);
                    }
                `;
                document.head.appendChild(styles);
            }
            
            document.body.appendChild(notification);
            
            // Auto-remover despu√©s de 10 segundos para errores
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 10000);
        }
        
        // Alternar detecci√≥n autom√°tica de direcci√≥n
        function toggleAutoDirection() {
            autoDirectionEnabled = !autoDirectionEnabled;
            const toggle = document.getElementById('autoDirectionToggle');
            
            if (autoDirectionEnabled) {
                toggle.textContent = 'üìç Auto: ON';
                toggle.style.color = '';
                console.log('‚úÖ Detecci√≥n autom√°tica ACTIVADA');
                
                // Intentar detectar inmediatamente si est√° activada
                if (Object.keys(stopsData).length > 0) {
                    detectAutoDirectionSilent().catch(error => {
                        console.log('‚ö†Ô∏è No se pudo detectar autom√°ticamente:', error.message);
                    });
                }
            } else {
                toggle.textContent = 'üìç Auto: OFF';
                toggle.style.color = '#999';
                console.log('‚ùå Detecci√≥n autom√°tica DESACTIVADA');
                
                // Ocultar icono de ubicaci√≥n cuando se desactiva
                updateLocationIcon(false);
            }
            
            // Guardar preferencia en localStorage
            try {
                localStorage.setItem('busCoruna_autoDirection', autoDirectionEnabled.toString());
            } catch (error) {
                console.warn('No se pudo guardar preferencia de detecci√≥n autom√°tica');
            }
        }
        

        
        // Cargar configuraci√≥n de rutas
        async function loadRoutesConfig(forceReload = false) {
            try {
                // Siempre agregar timestamp para evitar cach√© del navegador y Service Worker
                const timestamp = Date.now();
                const url = `routes.json?t=${timestamp}`;
                console.log('Cargando configuraci√≥n de rutas desde:', url);
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Error al cargar configuraci√≥n de rutas');
                }
                
                routesConfig = await response.json();
                console.log('Configuraci√≥n de rutas cargada:', routesConfig);
                
                // Establecer primera ruta disponible como ruta inicial
                const firstAvailableRoute = routesConfig.routes.find(r => r.active && r.type !== 'separator');
                if (firstAvailableRoute) {
                    currentRoute = {
                        id: firstAvailableRoute.id,
                        direction: firstAvailableRoute.direction,
                        originStop: firstAvailableRoute.originStop,
                        destinationStop: firstAvailableRoute.destinationStop,
                        originName: firstAvailableRoute.originName,
                        destinationName: firstAvailableRoute.destinationName
                    };
                }
                
                // Determinar direcci√≥n inicial bas√°ndose en el campo direction de la primera ruta
                if (firstAvailableRoute) {
                    currentDirection = firstAvailableRoute.direction || 'ida';
                }
                
                // Actualizar selector de destinos
                updateDestinationSelector();
                
            } catch (error) {
                console.error('Error cargando configuraci√≥n de rutas:', error);
                // Usar configuraci√≥n por defecto si falla
                currentRoute = {
                    id: '42-482',
                    direction: 'ida',
                    originStop: 42,
                    destinationStop: 482,
                    originName: 'E.Glez.L√≥pez, M.Aza√±a',
                    destinationName: 'A Maestranza, Metrosidero'
                };
            }
        }
        
        // Funci√≥n para seleccionar direcci√≥n (ida/vuelta)
        function selectDirection(direction) {
            console.log('üîÑ Cambiando direcci√≥n a:', direction);
            currentDirection = direction;
            
            // Actualizar botones
            const idaBtn = document.getElementById('idaBtn');
            const vueltaBtn = document.getElementById('vueltaBtn');
            
            if (direction === 'ida') {
                idaBtn.classList.add('active');
                vueltaBtn.classList.remove('active');
            } else {
                vueltaBtn.classList.add('active');
                idaBtn.classList.remove('active');
            }
            
            // Actualizar selector de destinos
            updateDestinationSelector();
        }
        
        // Actualizar selector de destinos seg√∫n la direcci√≥n
        function updateDestinationSelector() {
            const destinationSelect = document.getElementById('destinationSelect');
            const destinationLabel = document.querySelector('#destinationSelector label');
            
            destinationSelect.innerHTML = '<option value="loading">Cargando opciones...</option>';
            
            if (!routesConfig.routes) {
                console.error('No hay configuraci√≥n de rutas disponible');
                return;
            }
            
            // Filtrar rutas seg√∫n la direcci√≥n
            const availableRoutes = routesConfig.routes.filter(route => {
                if (route.type === 'separator' || !route.active) return false;
                
                // Usar el campo direction de la ruta
                return route.direction === currentDirection;
            });
            
            console.log(`Rutas disponibles para ${currentDirection}:`, availableRoutes);
            
            // Actualizar etiqueta
            if (currentDirection === 'ida') {
                destinationLabel.textContent = 'üìç ¬øD√≥nde quieres ir?';
            } else {
                destinationLabel.textContent = 'üìç ¬øDesde d√≥nde vienes?';
            }
            
            // Limpiar selector
            destinationSelect.innerHTML = '';
            
            // Agregar opciones
            availableRoutes.forEach(route => {
                const option = document.createElement('option');
                option.value = route.id;
                
                if (route.type === 'auto-fastest') {
                    option.textContent = route.name;
                    
                    // Verificar si deber√≠a estar deshabilitada de forma as√≠ncrona
                    checkIfAutoFastestShouldBeDisabled(option, route);
                    
                } else if (currentDirection === 'ida') {
                    option.textContent = `${route.name} (${route.destinationName})`;
                } else {
                    option.textContent = `${route.name} (${route.originName})`;
                }
                
                destinationSelect.appendChild(option);
            });
            
            // Establecer primera opci√≥n disponible
            // Peque√±o delay para permitir que checkIfAutoFastestShouldBeDisabled se ejecute
            setTimeout(() => {
                if (availableRoutes.length > 0) {
                    // Usar la primera opci√≥n disponible
                    const firstOption = destinationSelect.querySelector(`option[value="${availableRoutes[0].id}"]`);
                    if (firstOption && !firstOption.disabled) {
                        destinationSelect.value = availableRoutes[0].id;
                        selectRoute(availableRoutes[0].id);
                    } else {
                        // Si la primera est√° deshabilitada, buscar la primera habilitada
                        for (let i = 1; i < availableRoutes.length; i++) {
                            const option = destinationSelect.querySelector(`option[value="${availableRoutes[i].id}"]`);
                            if (option && !option.disabled) {
                                destinationSelect.value = availableRoutes[i].id;
                                selectRoute(availableRoutes[i].id);
                                break;
                            }
                        }
                    }
                }
            }, 100); // Peque√±o delay para permitir que se ejecuten las verificaciones as√≠ncronas
            
            // Agregar event listener
            destinationSelect.addEventListener('change', function() {
                selectRoute(this.value);
            });
        }
        
        // Verificar si la opci√≥n autom√°tica deber√≠a estar deshabilitada
        async function checkIfAutoFastestShouldBeDisabled(optionElement, route) {
            // Verificar si tenemos geolocalizaci√≥n y datos de paradas
            if (!userLocation || !autoDirectionEnabled || Object.keys(stopsData).length === 0) {
                // Deshabilitar la opci√≥n autom√°tica si no hay informaci√≥n de localizaci√≥n
                optionElement.disabled = true;
                optionElement.textContent = route.name + ' (No disponible - sin ubicaci√≥n)';
                optionElement.style.color = '#999';
                optionElement.style.fontStyle = 'italic';
                
                console.log(`üö´ Opci√≥n autom√°tica deshabilitada - sin informaci√≥n de ubicaci√≥n`);
                return;
            }
            
            try {
                // Usar la misma l√≥gica que findNearestStopForLines pero solo para verificaci√≥n
                const excludedStops = [42, 43, 44, 87, 88, 89, 90, 358, 553];
                const targetLineIds = route.targetLines;
                
                if (!targetLineIds || targetLineIds.length === 0) {
                    return;
                }
                
                // Encontrar paradas candidatas
                const candidateStops = {};
                
                Object.values(stopsData).forEach(stop => {
                    if (!stop.enlaces) return;
                    
                    const matchingLines = [];
                    stop.enlaces.forEach(lineId => {
                        if (targetLineIds.includes(lineId.toString())) {
                            matchingLines.push(lineId.toString());
                        }
                    });
                    
                    if (matchingLines.length > 0) {
                        const distance = calculateDistance(
                            userLocation.latitude,
                            userLocation.longitude,
                            stop.posy,
                            stop.posx
                        );
                        
                        candidateStops[stop.id] = {
                            stopId: stop.id,
                            distance: distance
                        };
                    }
                });
                
                if (Object.keys(candidateStops).length === 0) {
                    return;
                }
                
                // Encontrar la m√°s cercana
                let nearestStop = null;
                let minDistance = Infinity;
                
                Object.values(candidateStops).forEach(stop => {
                    if (stop.distance < minDistance) {
                        minDistance = stop.distance;
                        nearestStop = stop;
                    }
                });
                
                // Si la parada m√°s cercana est√° excluida, deshabilitar la opci√≥n
                if (nearestStop && excludedStops.includes(parseInt(nearestStop.stopId))) {
                    optionElement.disabled = true;
                    optionElement.textContent = route.name + ' (No disponible - muy cerca de casa)';
                    optionElement.style.color = '#999';
                    optionElement.style.fontStyle = 'italic';
                    
                    console.log(`üö´ Opci√≥n autom√°tica deshabilitada - parada ${nearestStop.stopId} excluida`);
                }
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error verificando disponibilidad de opci√≥n autom√°tica:', error);
                // En caso de error, deshabilitar la opci√≥n autom√°tica
                optionElement.disabled = true;
                optionElement.textContent = route.name + ' (No disponible - error de verificaci√≥n)';
                optionElement.style.color = '#999';
                optionElement.style.fontStyle = 'italic';
            }
        }
        
        // ========= FUNCIONES DE RUTA AUTOM√ÅTICA M√ÅS R√ÅPIDA =========
        
        // Manejar selecci√≥n autom√°tica de parada m√°s cercana
        async function handleAutoFastestRoute(selectedRoute) {
            console.log('üéØ Manejando ruta autom√°tica m√°s r√°pida:', selectedRoute);
            
            try {
                // Obtener ubicaci√≥n del usuario si no la tenemos
                if (!userLocation) {
                    console.log('üìç Obteniendo ubicaci√≥n para ruta autom√°tica...');
                    userLocation = await getUserLocation();
                }
                
                // Mostrar ubicaci√≥n del usuario en el mapa autom√°ticamente
                showUserLocationOnMap();
                
                // Encontrar la mejor parada para las l√≠neas objetivo
                const bestStopResult = await findNearestStopForLines(selectedRoute.targetLines, userLocation);
                
                if (!bestStopResult) {
                    console.warn('‚ö†Ô∏è No se pudo encontrar parada cercana, usando ruta manual por defecto');
                    // Fallback a la primera ruta de vuelta disponible
                    const fallbackRoute = routesConfig.routes.find(r => 
                        r.destinationStop === 88 && r.type !== 'auto-fastest' && r.active
                    );
                    if (fallbackRoute) {
                        selectRoute(fallbackRoute.id);
                    }
                    return;
                }
                
                // Verificar si la parada est√° excluida
                if (bestStopResult.excluded) {
                    console.log('üö´ Parada m√°s cercana excluida, mostrando notificaci√≥n');
                    showExcludedStopNotification(bestStopResult);
                    
                    // Fallback a la primera ruta de vuelta disponible
                    const fallbackRoute = routesConfig.routes.find(r => 
                        r.destinationStop === 88 && r.type !== 'auto-fastest' && r.active
                    );
                    if (fallbackRoute) {
                        selectRoute(fallbackRoute.id);
                    }
                    return;
                }
                
                console.log('‚úÖ Mejor parada encontrada:', bestStopResult);
                
                // Crear ruta combinada
                currentRoute = {
                    id: selectedRoute.id,
                    type: 'auto-fastest-combined',
                    lines: bestStopResult.lines, // Array de l√≠neas que pasan por esta parada
                    apiLineIds: bestStopResult.apiLineIds, // Array de IDs de API
                    originStop: bestStopResult.stopId,
                    destinationStop: selectedRoute.destinationStop,
                    originName: bestStopResult.stopName,
                    destinationName: selectedRoute.destinationName,
                    distance: bestStopResult.distance,
                    combinedName: bestStopResult.combinedName
                };
                
                console.log('üöÄ Ruta autom√°tica configurada:', currentRoute);
                
                // Mostrar notificaci√≥n al usuario
                showAutoRouteNotification(bestStopResult);
                
                // Recargar datos con la nueva ruta combinada
                refreshRouteData();
                
            } catch (error) {
                console.error('‚ùå Error en ruta autom√°tica:', error);
                showAutoRouteErrorNotification(error.message);
                
                // Fallback a ruta manual
                const fallbackRoute = routesConfig.routes.find(r => 
                    r.destinationStop === 88 && r.type !== 'auto-fastest' && r.active
                );
                if (fallbackRoute) {
                    selectRoute(fallbackRoute.id);
                }
            }
        }
        
        // Encontrar la parada m√°s cercana para las l√≠neas especificadas
        async function findNearestStopForLines(targetLineIds, location) {
            console.log('üîç Buscando parada m√°s cercana para l√≠neas:', targetLineIds);
            
            if (!location || !targetLineIds || targetLineIds.length === 0) {
                return null;
            }
            
            // Paradas excluidas (muy cerca de casa, no necesitan funci√≥n autom√°tica)
            const excludedStops = [42, 43, 44, 87, 88, 89, 90, 358, 553];
            
            // Mapear todas las paradas que sirven las l√≠neas objetivo
            const candidateStops = {};
            
            // Buscar paradas de las l√≠neas objetivo en los datos generales
            Object.values(stopsData).forEach(stop => {
                if (!stop.enlaces) return;
                
                // Verificar si alguna de las l√≠neas objetivo pasa por esta parada
                const matchingLines = [];
                stop.enlaces.forEach(lineId => {
                    if (targetLineIds.includes(lineId.toString())) {
                        matchingLines.push(lineId.toString());
                    }
                });
                
                if (matchingLines.length > 0) {
                    const distance = calculateDistance(
                        location.latitude,
                        location.longitude,
                        stop.posy,
                        stop.posx
                    );
                    
                    candidateStops[stop.id] = {
                        stopId: stop.id,
                        stopName: stop.nombre,
                        distance: distance,
                        lines: matchingLines,
                        coordinates: { lat: stop.posy, lng: stop.posx }
                    };
                }
            });
            
            if (Object.keys(candidateStops).length === 0) {
                console.warn('‚ö†Ô∏è No se encontraron paradas para las l√≠neas objetivo');
                return null;
            }
            
            // Encontrar la parada m√°s cercana
            let nearestStop = null;
            let minDistance = Infinity;
            
            Object.values(candidateStops).forEach(stop => {
                if (stop.distance < minDistance) {
                    minDistance = stop.distance;
                    nearestStop = stop;
                }
            });
            
            if (!nearestStop) {
                return null;
            }
            
            // Verificar si la parada m√°s cercana est√° en la lista de excluidas
            if (excludedStops.includes(parseInt(nearestStop.stopId))) {
                console.log(`üö´ Parada ${nearestStop.stopId} (${nearestStop.stopName}) est√° excluida - muy cerca de casa`);
                return { excluded: true, stopId: nearestStop.stopId, stopName: nearestStop.stopName, distance: nearestStop.distance };
            }
            
            // Enriquecer con informaci√≥n adicional
            const lineNames = nearestStop.lines.map(lineId => {
                const apiId = parseInt(lineId);
                if (apiId === 300) return '3';
                if (apiId === 301) return '3A';
                if (apiId === 1200) return '12';
                if (apiId === 1400) return '14';
                return lineId;
            });
            
            nearestStop.apiLineIds = nearestStop.lines;
            nearestStop.lineNames = lineNames;
            nearestStop.combinedName = lineNames.length > 1 
                ? `L√≠nea ${lineNames.join(' y L√≠nea ')}`
                : `L√≠nea ${lineNames[0]}`;
            
            console.log('üéØ Parada m√°s cercana seleccionada:', nearestStop);
            return nearestStop;
        }
        
        // Encontrar todas las l√≠neas de inter√©s que conecten paradas origen y destino
        function findLinesConnectingStops(originStopId, destinationStopId) {
            console.log('üîç Buscando l√≠neas que conecten paradas:', originStopId, '‚Üí', destinationStopId);
            
            // L√≠neas de inter√©s con sus mapeos (expandir para incluir m√°s l√≠neas)
            const targetLines = ['100', '1900', '200', '800', '300', '301', '400', '500', '600', '601', '700', '1100', '1200', '1500', '1400', '1700', '2000', '2100', '2200', '2300', '2301', '2400', '1800', '1801', '2450', '2451'];
            const lineMapping = {
                '100': '1',
                '1900': '1A',
                '200': '2',
                '800': '2A',
                '300': '3',
                '301': '3A', 
                '400': '4',
                '500': '5',
                '600': '6',
                '601': '6A',
                '700': '7',
                '1100': '11',
                '1200': '12',
                '1500': '12A',
                '1400': '14',
                '1700': '17',
                '2000': '20',
                '2100': '21',
                '2200': '22',
                '2300': '23',
                '2301': '23A',
                '2400': '24',
                '1800': 'BUH',
                '1801': 'BUH',
                '2450': 'UDC',
                '2451': 'UDC'
            };
            
            if (!stopsData || Object.keys(stopsData).length === 0) {
                console.warn('‚ö†Ô∏è stopsData no disponible');
                return null;
            }
            
            // Obtener informaci√≥n de paradas origen y destino
            const originStop = stopsData[originStopId];
            const destinationStop = stopsData[destinationStopId];
            
            console.log('üìç Parada origen:', originStop);
            console.log('üìç Parada destino:', destinationStop);
            
            if (!originStop || !destinationStop) {
                console.warn('‚ö†Ô∏è No se encontraron las paradas:', originStopId, destinationStopId);
                console.log('üìä Paradas disponibles:', Object.keys(stopsData));
                return null;
            }
            
            if (!originStop.enlaces || !destinationStop.enlaces) {
                console.warn('‚ö†Ô∏è Paradas sin informaci√≥n de enlaces');
                console.log('üîó Enlaces origen:', originStop.enlaces);
                console.log('üîó Enlaces destino:', destinationStop.enlaces);
                return null;
            }
            
            // Encontrar l√≠neas que pasen por ambas paradas
            const originLines = originStop.enlaces.map(id => id.toString());
            const destinationLines = destinationStop.enlaces.map(id => id.toString());
            
            console.log('üìç L√≠neas en origen:', originLines);
            console.log('üìç L√≠neas en destino:', destinationLines);
            console.log('üéØ L√≠neas objetivo:', targetLines);
            
            // Buscar intersecci√≥n con l√≠neas de inter√©s
            const matchingLines = [];
            targetLines.forEach(lineId => {
                if (originLines.includes(lineId) && destinationLines.includes(lineId)) {
                    const lineName = lineMapping[lineId] || lineId; // Usar el ID original si no hay mapeo
                    console.log(`üîó Mapeando l√≠nea ${lineId} ‚Üí ${lineName}`);
                    matchingLines.push({
                        apiLineId: lineId,
                        lineId: lineName
                    });
                }
            });
            
            console.log('‚úÖ L√≠neas coincidentes encontradas:', matchingLines);
            
            if (matchingLines.length === 0) {
                console.log('‚ö†Ô∏è No se encontraron l√≠neas de inter√©s que conecten ambas paradas');
                
                // Fallback: buscar cualquier l√≠nea que conecte las paradas
                console.log('üîÑ Intentando fallback: buscar cualquier l√≠nea que conecte las paradas...');
                const commonLines = originLines.filter(lineId => destinationLines.includes(lineId));
                console.log('üîó L√≠neas comunes encontradas:', commonLines);
                
                if (commonLines.length > 0) {
                    // Usar la primera l√≠nea com√∫n encontrada
                    const fallbackLineId = commonLines[0];
                    const fallbackLineName = lineMapping[fallbackLineId] || fallbackLineId;
                    
                    console.log(`üîÑ Usando l√≠nea de fallback: ${fallbackLineId} ‚Üí ${fallbackLineName}`);
                    
                    const fallbackResult = {
                        lines: [fallbackLineId],
                        apiLineIds: [fallbackLineId],
                        lineNames: [fallbackLineName],
                        combinedName: `L√≠nea ${fallbackLineName}`,
                        originStopId: originStopId,
                        destinationStopId: destinationStopId,
                        originStopName: originStop.nombre,
                        destinationStopName: destinationStop.nombre
                    };
                    
                    console.log('‚úÖ Resultado de fallback:', fallbackResult);
                    return fallbackResult;
                }
                
                return null;
            }
            
            console.log('‚úÖ L√≠neas encontradas que conectan las paradas:', matchingLines);
            
            // Crear objeto resultado similar al de findNearestStopForLines
            const lineNames = matchingLines.map(line => line.lineId);
            const apiLineIds = matchingLines.map(line => line.apiLineId);
            
            console.log('üìã Nombres de l√≠neas mapeados:', lineNames);
            console.log('üî¢ IDs de API de l√≠neas:', apiLineIds);
            
            // Filtrar valores undefined
            const validLineNames = lineNames.filter(name => name && name !== 'undefined' && name !== undefined);
            const validApiLineIds = apiLineIds.filter(id => id && id !== 'undefined' && id !== undefined);
            
            console.log('‚úÖ Nombres de l√≠neas v√°lidos:', validLineNames);
            console.log('‚úÖ IDs de API v√°lidos:', validApiLineIds);
            
            // Verificar que tenemos al menos una l√≠nea v√°lida despu√©s de filtrar
            if (validLineNames.length === 0) {
                console.log('‚ö†Ô∏è No se encontraron nombres de l√≠neas v√°lidos despu√©s del filtrado');
                return null;
            }
            
            // Construir combinedName con debugging
            const combinedName = validLineNames.length > 1 
                ? `L√≠neas ${validLineNames.join(' y ')}`
                : `L√≠nea ${validLineNames[0] || 'N/A'}`;
            
            console.log('üè∑Ô∏è Combined name construido:', combinedName);
            console.log('üîç Primer nombre de l√≠nea:', validLineNames[0]);
            
            const result = {
                lines: validApiLineIds,
                apiLineIds: validApiLineIds,
                lineNames: validLineNames,
                combinedName: combinedName,
                originStopId: originStopId,
                destinationStopId: destinationStopId,
                originStopName: originStop.nombre,
                destinationStopName: destinationStop.nombre
            };
            
            return result;
        }
        
        // Manejar ruta normal con m√∫ltiples l√≠neas
        async function handleMultiLineNormalRoute(selectedRoute) {
            console.log('üöå Manejando ruta normal con m√∫ltiples l√≠neas:', selectedRoute);
            
            // Buscar l√≠neas que conecten las paradas de la ruta
            const connectingLines = findLinesConnectingStops(
                selectedRoute.originStop, 
                selectedRoute.destinationStop
            );
            
            if (!connectingLines || connectingLines.lines.length <= 1) {
                console.log('üìç Solo hay una l√≠nea o ninguna l√≠nea alternativa, usando ruta normal');
                // Usar ruta normal est√°ndar
                currentRoute = {
                    id: selectedRoute.id,
                    direction: selectedRoute.direction,
                    originStop: selectedRoute.originStop,
                    destinationStop: selectedRoute.destinationStop,
                    originName: selectedRoute.originName,
                    destinationName: selectedRoute.destinationName
                };
            } else {
                console.log('üéØ M√∫ltiples l√≠neas encontradas, creando ruta combinada');
                // Crear ruta combinada con m√∫ltiples l√≠neas
                currentRoute = {
                    id: selectedRoute.id,
                    type: 'multi-line-normal',
                    direction: selectedRoute.direction,
                    lines: connectingLines.lineNames, // Array de nombres de l√≠neas  
                    apiLineIds: connectingLines.apiLineIds, // Array de IDs de API
                    originStop: selectedRoute.originStop,
                    destinationStop: selectedRoute.destinationStop,
                    originName: selectedRoute.originName,
                    destinationName: selectedRoute.destinationName,
                    combinedName: connectingLines.combinedName
                };
                
                // Mostrar notificaci√≥n al usuario
                showMultiLineNotification(connectingLines);
            }
            
            // Recargar datos con la nueva ruta
            refreshRouteData();
        }
        
        // Mostrar notificaci√≥n de m√∫ltiples l√≠neas disponibles
        function showMultiLineNotification(linesResult) {
            const notification = document.createElement('div');
            notification.className = 'location-notification multi-line';
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">üöå</span>
                    <span class="notification-text">
                        M√∫ltiples l√≠neas disponibles: <strong>${linesResult.combinedName}</strong><br>
                        <small>${linesResult.originStopName} ‚Üí ${linesResult.destinationStopName}</small>
                    </span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            // A√±adir estilos espec√≠ficos si no existen
            if (!document.querySelector('#multi-line-styles')) {
                const styles = document.createElement('style');
                styles.id = 'multi-line-styles';
                styles.textContent = `
                    .location-notification.multi-line {
                        background: linear-gradient(135deg, #4CAF50, #388E3C);
                    }
                `;
                document.head.appendChild(styles);
            }
            
            document.body.appendChild(notification);
            
            // Auto-remover despu√©s de 6 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 6000);
        }
        
        // Mostrar notificaci√≥n de ruta autom√°tica seleccionada
        function showAutoRouteNotification(stopResult) {
            const notification = document.createElement('div');
            notification.className = 'location-notification auto-route';
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">üéØ</span>
                    <span class="notification-text">
                        Parada m√°s cercana: <strong>${stopResult.stopName}</strong> (${Math.round(stopResult.distance)}m)<br>
                        <small>${stopResult.combinedName} ‚Üí Casa</small>
                    </span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            // A√±adir estilos espec√≠ficos si no existen
            if (!document.querySelector('#auto-route-styles')) {
                const styles = document.createElement('style');
                styles.id = 'auto-route-styles';
                styles.textContent = `
                    .location-notification.auto-route {
                        background: linear-gradient(135deg, #2196F3, #1976D2);
                    }
                `;
                document.head.appendChild(styles);
            }
            
            document.body.appendChild(notification);
            
            // Auto-remover despu√©s de 6 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 6000);
        }
        
        // Mostrar notificaci√≥n cuando la parada m√°s cercana est√° excluida
        function showExcludedStopNotification(stopResult) {
            const notification = document.createElement('div');
            notification.className = 'location-notification excluded';
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">üö´</span>
                    <span class="notification-text">
                        Ya est√°s muy cerca de casa (${Math.round(stopResult.distance)}m de ${stopResult.stopName}). 
                        <br><small>Usa las rutas manuales para seleccionar tu destino espec√≠fico.</small>
                    </span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            // A√±adir estilos espec√≠ficos si no existen
            if (!document.querySelector('#excluded-stop-styles')) {
                const styles = document.createElement('style');
                styles.id = 'excluded-stop-styles';
                styles.textContent = `
                    .location-notification.excluded {
                        background: linear-gradient(135deg, #FF9800, #F57C00);
                    }
                `;
                document.head.appendChild(styles);
            }
            
            document.body.appendChild(notification);
            
            // Auto-remover despu√©s de 8 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 8000);
        }
        
        // Mostrar notificaci√≥n de error en ruta autom√°tica
        function showAutoRouteErrorNotification(errorMessage) {
            const notification = document.createElement('div');
            notification.className = 'location-notification error';
            notification.innerHTML = `
                <div class="notification-content">
                    <span class="notification-icon">‚ùå</span>
                    <span class="notification-text">
                        No se pudo encontrar la parada m√°s cercana: ${errorMessage}. 
                        Usando ruta manual por defecto.
                    </span>
                    <button class="notification-close" onclick="this.parentElement.parentElement.remove()">√ó</button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remover despu√©s de 8 segundos
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 8000);
        }
        
        // Seleccionar ruta espec√≠fica
        async function selectRoute(routeId) {
            const selectedRoute = routesConfig.routes.find(r => r.id === routeId);
            if (selectedRoute && selectedRoute.type !== 'separator') {
                console.log('üîÑ Seleccionando ruta:', selectedRoute);
                
                if (selectedRoute.type === 'auto-fastest') {
                    // Verificar si la opci√≥n est√° deshabilitada en el selector
                    const optionElement = document.querySelector(`option[value="${routeId}"]`);
                    if (optionElement && optionElement.disabled) {
                        console.warn('üö´ Intento de seleccionar opci√≥n autom√°tica deshabilitada, usando fallback');
                        // Usar la primera ruta manual disponible
                        const fallbackRoute = routesConfig.routes.find(r => 
                            r.destinationStop === 88 && r.type !== 'auto-fastest' && r.active
                        );
                        if (fallbackRoute) {
                            selectRoute(fallbackRoute.id);
                        }
                        return;
                    }
                    
                    // Manejar selecci√≥n autom√°tica de parada m√°s cercana
                    await handleAutoFastestRoute(selectedRoute);
                } else {
                    // Manejar ruta normal con b√∫squeda de m√∫ltiples l√≠neas
                    await handleMultiLineNormalRoute(selectedRoute);
                }
            }
        }
        
                // Recargar datos de la ruta
        function refreshRouteData() {
            console.log('üîÑ Recargando datos para ruta:', currentRoute);
            console.log('üìä Estado de cach√© antes de limpiar:');
            console.log('   - L√≠neas en cach√©:', Object.keys(linesData).length);
            console.log('   - Paradas en cach√©:', Object.keys(stopsData).length);
            
            // Limpiar cach√© de datos anteriores
            linesData = {};
            stopsData = {};
            
            // Limpiar mapa
            if (routeLayer) {
                routeLayer.clearLayers();
            }
            
            // Limpiar marcador de ubicaci√≥n del usuario
            hideUserLocationFromMap();
            
            // Limpiar lista de paradas
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = `
                <li class="loading">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 20px; margin-bottom: 8px;">üìç</div>
                        <div style="font-size: 16px; color: #666;">Cargando paradas...</div>
                    </div>
                </li>
            `;
            
            // Limpiar tiempos de llegada
            const arrivalsList = document.getElementById('arrivalsList');
            arrivalsList.innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üöå</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Cargando tiempos de llegada...</div>
                        <div style="font-size: 14px; color: #999;">Conectando con el servicio en tiempo real</div>
                    </div>
                </div>
            `;
            
            // Limpiar horarios
            const scheduleInfo = document.getElementById('scheduleInfo');
            scheduleInfo.innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚è≥</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Cargando horarios...</div>
                        <div style="font-size: 14px; color: #999;">Obteniendo informaci√≥n actualizada</div>
                    </div>
                </div>
            `;
            
            console.log('üßπ Cach√© limpiada completamente');
            
            // Actualizar t√≠tulo de pr√≥ximos buses
            updateArrivalTitle();
            
            // Recargar datos
            getGeneralData();
            getScheduleData();
            getArrivalTime();
        }
        
        // Actualizar t√≠tulo de pr√≥ximos buses
        function updateArrivalTitle() {
            const arrivalInfo = document.getElementById('arrivalInfo');
            if (arrivalInfo && currentRoute) {
                const h2 = arrivalInfo.querySelector('h2');
                if (h2) {
                    // Asegurar que tenemos nombres v√°lidos
                    const originName = currentRoute.originName || 'Parada origen';
                    const originStop = currentRoute.originStop || '---';
                    
                    if (currentRoute.type === 'auto-fastest-combined' || currentRoute.type === 'multi-line-normal') {
                        const combinedName = currentRoute.combinedName || 'M√∫ltiples l√≠neas';
                        h2.textContent = `‚è±Ô∏è Pr√≥ximos buses en ${originName} (Parada ${originStop}) - ${combinedName}`;
                    } else {
                        // Para rutas individuales, buscar l√≠neas que conecten las paradas
                        const connectingLines = findLinesConnectingStops(
                            currentRoute.originStop, 
                            currentRoute.destinationStop
                        );
                        
                        if (connectingLines && connectingLines.lines.length > 0) {
                            const lineInfo = ` - ${connectingLines.combinedName}`;
                            h2.textContent = `‚è±Ô∏è Pr√≥ximos buses en ${originName} (Parada ${originStop})${lineInfo}`;
                        } else {
                            h2.textContent = `‚è±Ô∏è Pr√≥ximos buses en ${originName} (Parada ${originStop})`;
                        }
                    }
                }
            }
        }
        
        // Inicializar mapa
        function initMap() {
            try {
                map = L.map('map').setView([43.3623, -8.4115], 14);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(map);
                
                routeLayer = L.layerGroup().addTo(map);
            } catch (error) {
                console.error('Error inicializando mapa:', error);
                document.getElementById('map').innerHTML = '<div class="error">Error al cargar el mapa</div>';
            }
        }
        
        // Obtener datos generales (l√≠neas y paradas)
        async function getGeneralData() {
            console.log('üì° Iniciando getGeneralData...');
            console.log('üìä Estado de cach√© al inicio:');
            console.log('   - L√≠neas en cach√©:', Object.keys(linesData).length);
            console.log('   - Paradas en cach√©:', Object.keys(stopsData).length);
            
            // Intentar primero con localStorage
            const cachedData = getCache(CACHE_KEYS.GENERAL_DATA);
            if (cachedData) {
                console.log('üéØ [localStorage] Usando datos generales del cach√©');
                
                // Procesar datos del cach√©
                if (cachedData.iTranvias && cachedData.iTranvias.actualizacion) {
                    if (cachedData.iTranvias.actualizacion.lineas) {
                        cachedData.iTranvias.actualizacion.lineas.forEach(linea => {
                            linesData[linea.id] = linea;
                        });
                        console.log('L√≠neas cargadas desde cach√©:', Object.keys(linesData));
                    }
                    
                    if (cachedData.iTranvias.actualizacion.paradas) {
                        cachedData.iTranvias.actualizacion.paradas.forEach(parada => {
                            stopsData[parada.id] = parada;
                        });
                        console.log('Paradas cargadas desde cach√©:', Object.keys(stopsData).length);
                    }
                }
                
                // Obtener informaci√≥n espec√≠fica de la l√≠nea
                await getLineData();
                return;
            }
            
            try {
                console.log('üåê Intentando con backend...');
                const response = await fetch(`${BACKEND_API}/general`);
                
                if (!response.ok) {
                    throw new Error(`Error al obtener datos generales: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ Datos generales recibidos del backend:', data);
                
                if (!data || !data.iTranvias || !data.iTranvias.actualizacion) {
                    throw new Error('Estructura de datos incorrecta');
                }
                
                // Guardar en cach√© localStorage
                setCache(CACHE_KEYS.GENERAL_DATA, data, CACHE_TTL.STATIC);
                
                // Procesar l√≠neas
                if (data.iTranvias.actualizacion.lineas) {
                    console.log('üìã Datos de l√≠neas recibidos:', data.iTranvias.actualizacion.lineas);
                    data.iTranvias.actualizacion.lineas.forEach(linea => {
                        linesData[linea.id] = linea;
                        console.log(`  - L√≠nea ${linea.id}:`, linea);
                    });
                    console.log('L√≠neas cargadas:', Object.keys(linesData));
                }
                
                // Procesar paradas
                if (data.iTranvias.actualizacion.paradas) {
                    data.iTranvias.actualizacion.paradas.forEach(parada => {
                        stopsData[parada.id] = parada;
                    });
                    console.log('Paradas cargadas:', Object.keys(stopsData).length);
                }
                
                // Obtener informaci√≥n espec√≠fica de la l√≠nea
                console.log('Llamando a getLineData...');
                await getLineData();
                
            } catch (error) {
                console.error('‚ùå Error en getGeneralData:', error);
                console.error('Error details:', error.message);
                
                // Intentar con cach√© expirado como √∫ltimo recurso
                const expiredCache = localStorage.getItem(CACHE_KEYS.GENERAL_DATA);
                if (expiredCache) {
                    console.log('üÜò [localStorage] Usando cach√© expirado como √∫ltimo recurso');
                    try {
                        const cacheData = JSON.parse(expiredCache);
                        const data = cacheData.data;
                        
                        if (data && data.iTranvias && data.iTranvias.actualizacion) {
                            if (data.iTranvias.actualizacion.lineas) {
                                data.iTranvias.actualizacion.lineas.forEach(linea => {
                                    linesData[linea.id] = linea;
                                });
                            }
                            
                            if (data.iTranvias.actualizacion.paradas) {
                                data.iTranvias.actualizacion.paradas.forEach(parada => {
                                    stopsData[parada.id] = parada;
                                });
                            }
                            
                            await getLineData();
                            return;
                        }
                    } catch (cacheError) {
                        console.error('‚ùå Error procesando cach√© expirado:', cacheError);
                    }
                }
                
                showConnectionError();
            }
        }
        
        // Obtener datos espec√≠ficos de una l√≠nea
        async function getLineData() {
            console.log('Iniciando getLineData...');
            
            // Manejar rutas combinadas vs individuales
            if (currentRoute.type === 'auto-fastest-combined' || currentRoute.type === 'multi-line-normal') {
                console.log('üöå Ruta combinada detectada, manejando m√∫ltiples l√≠neas');
                // Para rutas combinadas, llamar displayLineInfo para mostrar paradas
                displayLineInfo();
                return;
            }
            
            // Para rutas individuales, buscar l√≠neas que conecten las paradas
            const connectingLines = findLinesConnectingStops(
                currentRoute.originStop, 
                currentRoute.destinationStop
            );
            
            if (!connectingLines || connectingLines.lines.length === 0) {
                console.warn('getLineData: No se encontraron l√≠neas que conecten las paradas');
                console.log('currentRoute actual:', currentRoute);
                return;
            }
            
                        // Usar la primera l√≠nea disponible
            const firstLineId = connectingLines.apiLineIds[0];
            const lineDataKey = CACHE_KEYS.LINE_DATA + firstLineId;
            
            // Intentar primero con localStorage
            const cachedData = getCache(lineDataKey);
            if (cachedData) {
                console.log(`üéØ [localStorage] Usando datos de l√≠nea ${firstLineId} del cach√©`);
                displayLineInfo();
                return;
            }
            
            try {
                console.log('Intentando con backend para datos de l√≠nea...');
                const response = await fetch(`${BACKEND_API}/line/${firstLineId}`);
                
                if (!response.ok) {
                    throw new Error('Error al obtener datos de la l√≠nea');
                }
                
                const data = await response.json();
                console.log(`Datos de l√≠nea ${firstLineId} recibidos del backend:`, data);
                
                // Guardar en cach√© localStorage
                setCache(lineDataKey, data, CACHE_TTL.STATIC);
                
                // Mostrar informaci√≥n de la l√≠nea
                displayLineInfo();
                
            } catch (error) {
                console.error('Error en getLineData:', error);
                
                // Intentar con cach√© expirado como √∫ltimo recurso
                const expiredCache = localStorage.getItem(lineDataKey);
                if (expiredCache) {
                    console.log(`üÜò [localStorage] Usando cach√© expirado para l√≠nea ${firstLineId}`);
                    displayLineInfo();
                    return;
                }
                
                // Si falla el backend, continuar con los datos ya cargados
                console.log('Continuando con datos ya cargados...');
                displayLineInfo();
            }
        }
        
        // Mostrar informaci√≥n de la l√≠nea
        function displayLineInfo() {
            console.log('üîç Iniciando displayLineInfo...');
            console.log('üìä L√≠neas disponibles:', Object.keys(linesData));
            console.log('üìç Paradas disponibles:', Object.keys(stopsData));
            console.log('üéØ Ruta actual:', currentRoute);
            
            // Manejar rutas combinadas vs individuales
            if (currentRoute.type === 'auto-fastest-combined' || currentRoute.type === 'multi-line-normal') {
                console.log('üöå Ruta combinada detectada, manejando m√∫ltiples l√≠neas');
                
                if (currentRoute.type === 'multi-line-normal') {
                    // Para rutas multilinea normales, mostrar paradas de la primera l√≠nea disponible
                    displayMultiLineStops();
                }
                return;
            }
            
            // Para rutas normales, buscar l√≠neas que conecten las paradas
            const connectingLines = findLinesConnectingStops(
                currentRoute.originStop, 
                currentRoute.destinationStop
            );
            
            if (!connectingLines || connectingLines.lines.length === 0) {
                console.error(`‚ùå No se encontraron l√≠neas que conecten las paradas ${currentRoute.originStop} y ${currentRoute.destinationStop}`);
                console.error('üîç L√≠neas disponibles en cach√©:', Object.keys(linesData));
                showConnectionError();
                return;
            }
            
            // Usar la primera l√≠nea disponible
            const firstLineId = connectingLines.apiLineIds[0];
            const currentLine = linesData[firstLineId];
            
            if (!currentLine) {
                console.error(`‚ùå No se encontr√≥ informaci√≥n de la l√≠nea ${firstLineId}`);
                console.error('üîç L√≠neas disponibles en cach√©:', Object.keys(linesData));
                showConnectionError();
                return;
            }
            
            console.log(`‚úÖ L√≠nea ${firstLineId} encontrada:`, currentLine);
            console.log(`üõ£Ô∏è Rutas de la l√≠nea ${firstLineId}:`, currentLine.rutas);
            
            // Obtener paradas de la l√≠nea actual
            const routeStops = [];
            
            // Las paradas vienen en el campo 'rutas' de la l√≠nea
            if (currentLine.rutas && currentLine.rutas.length > 0) {
                // Determinar qu√© ruta usar bas√°ndose en los puntos de origen y destino
                let rutaSeleccionada = null;
                let mejorCoincidencia = -1;
                
                console.log(`üîç Analizando ${currentLine.rutas.length} rutas disponibles para l√≠nea ${firstLineId}`);
                
                // Buscar la ruta que contenga tanto el origen como el destino
                // Considerar la direcci√≥n (ida/vuelta) para seleccionar la ruta correcta
                for (let rutaIndex = 0; rutaIndex < currentLine.rutas.length; rutaIndex++) {
                    const ruta = currentLine.rutas[rutaIndex];
                    console.log(`üìã Analizando ruta ${rutaIndex + 1}:`, ruta);
                    
                    if (ruta.paradas) {
                        const stopIds = ruta.paradas;
                        console.log(`üìç Paradas en ruta ${rutaIndex + 1}:`, stopIds);
                        
                        // Verificar si esta ruta corresponde a la direcci√≥n actual
                        const rutaDirection = determineRouteDirection(ruta, firstLineId);
                        console.log(`üéØ Ruta ${rutaIndex + 1} - Direcci√≥n detectada: ${rutaDirection}`);
                        
                        // Solo considerar rutas que coincidan con la direcci√≥n actual
                        if (rutaDirection !== currentDirection) {
                            console.log(`‚è≠Ô∏è Ruta ${rutaIndex + 1} descartada - direcci√≥n no coincide (${rutaDirection} vs ${currentDirection})`);
                            continue;
                        }
                        
                        // Buscar √≠ndices de origen y destino en esta ruta
                        let startIndex = -1;
                        let endIndex = -1;
                        
                        for (let i = 0; i < stopIds.length; i++) {
                            if (stopIds[i] === currentRoute.originStop) {
                                startIndex = i;
                            }
                            if (stopIds[i] === currentRoute.destinationStop) {
                                endIndex = i;
                            }
                        }
                        
                        console.log(`üéØ Ruta ${rutaIndex + 1} - √çndice origen: ${startIndex}, √çndice destino: ${endIndex}`);
                        
                        // Verificar que ambos puntos est√©n en la ruta
                        if (startIndex !== -1 && endIndex !== -1) {
                            const coincidencia = Math.abs(endIndex - startIndex) + 1; // N√∫mero de paradas en el recorrido
                            console.log(`‚úÖ Ruta ${rutaIndex + 1} v√°lida con ${coincidencia} paradas en recorrido (${currentDirection})`);
                            
                            if (coincidencia > mejorCoincidencia) {
                                mejorCoincidencia = coincidencia;
                                rutaSeleccionada = ruta;
                                console.log(`üèÜ Nueva mejor ruta encontrada: ruta ${rutaIndex + 1} (${currentDirection})`);
                            }
                        } else {
                            console.log(`‚ùå Ruta ${rutaIndex + 1} descartada - no contiene ambos puntos`);
                        }
                    }
                }
                
                if (rutaSeleccionada) {
                    console.log('‚úÖ Ruta seleccionada:', rutaSeleccionada);
                    
                    const stopIds = rutaSeleccionada.paradas;
                    console.log('IDs de paradas en la ruta seleccionada:', stopIds);
                    console.log('Origen buscado:', currentRoute.originStop);
                    console.log('Destino buscado:', currentRoute.destinationStop);
                    
                    // Buscar el recorrido entre origen y destino
                    let startIndex = -1;
                    let endIndex = -1;
                    
                    for (let i = 0; i < stopIds.length; i++) {
                        if (stopIds[i] === currentRoute.originStop) {
                            startIndex = i;
                        }
                        if (stopIds[i] === currentRoute.destinationStop) {
                            endIndex = i;
                        }
                    }
                    
                    console.log('√çndice de inicio:', startIndex);
                    console.log('√çndice de fin:', endIndex);
                    
                    // Verificar que ambos puntos est√©n en la ruta
                    if (startIndex !== -1 && endIndex !== -1) {
                        // Obtener las paradas del recorrido en el orden correcto
                        const startIdx = Math.min(startIndex, endIndex);
                        const endIdx = Math.max(startIndex, endIndex);
                        
                        for (let i = startIdx; i <= endIdx; i++) {
                            const stopId = stopIds[i];
                            if (stopsData[stopId]) {
                                routeStops.push(stopsData[stopId]);
                            }
                        }
                    }
                } else {
                    console.warn('‚ö†Ô∏è No se encontr√≥ una ruta v√°lida que contenga origen y destino');
                    console.log('üîç Rutas disponibles:', currentLine.rutas);
                    console.log('üéØ Buscando origen:', currentRoute.originStop, 'destino:', currentRoute.destinationStop);
                }
            }
            
            console.log('Paradas del recorrido encontradas:', routeStops.length);
            displaySingleRouteWithHeader(routeStops, connectingLines.lineNames[0], getLineColor(firstLineId));
            displayMapRouteWithColor(routeStops, getLineColor(firstLineId), connectingLines.lineNames[0]);
        }
        
        // Mostrar paradas para rutas multilinea
        function displayMultiLineStops() {
            console.log('üöå Iniciando displayMultiLineStops para ruta multilinea...');
            
            if (!currentRoute.apiLineIds || currentRoute.apiLineIds.length === 0) {
                console.warn('displayMultiLineStops: No se encontraron apiLineIds');
                return;
            }
            

            
            // Obtener todas las rutas v√°lidas de todas las l√≠neas
            const allRoutes = [];
            
            currentRoute.apiLineIds.forEach((lineId, lineIndex) => {
                const currentLine = linesData[lineId];
                if (!currentLine || !currentLine.rutas) {
                    console.warn(`‚ö†Ô∏è No se encontr√≥ informaci√≥n de rutas para l√≠nea ${lineId}`);
                    return;
                }
                
                console.log(`üîç Analizando rutas de l√≠nea ${lineId}:`, currentLine.rutas);
                
                // Buscar rutas v√°lidas para esta l√≠nea
                currentLine.rutas.forEach((ruta, rutaIndex) => {
                    if (ruta.paradas) {
                        const stopIds = ruta.paradas;
                        
                        // Verificar si esta ruta corresponde a la direcci√≥n actual
                        const rutaDirection = determineRouteDirection(ruta, lineId);
                        console.log(`üéØ Ruta ${rutaIndex + 1} de l√≠nea ${lineId} - Direcci√≥n detectada: ${rutaDirection}`);
                        
                        // Solo considerar rutas que coincidan con la direcci√≥n actual
                        if (rutaDirection !== currentDirection) {
                            console.log(`‚è≠Ô∏è Ruta ${rutaIndex + 1} de l√≠nea ${lineId} descartada - direcci√≥n no coincide (${rutaDirection} vs ${currentDirection})`);
                            return;
                        }
                        
                        let startIndex = -1;
                        let endIndex = -1;
                        
                        for (let i = 0; i < stopIds.length; i++) {
                            if (stopIds[i] === currentRoute.originStop) {
                                startIndex = i;
                            }
                            if (stopIds[i] === currentRoute.destinationStop) {
                                endIndex = i;
                            }
                        }
                        
                        // Verificar que ambos puntos est√©n en la ruta
                        if (startIndex !== -1 && endIndex !== -1) {
                            allRoutes.push({
                                lineId: lineId,
                                lineName: currentRoute.lines[lineIndex],
                                ruta: ruta,
                                startIndex: startIndex,
                                endIndex: endIndex,
                                direction: currentDirection
                            });
                            console.log(`‚úÖ Ruta v√°lida encontrada para l√≠nea ${lineId} (${currentDirection}):`, ruta);
                        } else {
                            console.log(`‚ùå Ruta ${rutaIndex + 1} de l√≠nea ${lineId} descartada - no contiene ambos puntos`);
                        }
                    }
                });
            });
            
            console.log('üìã Todas las rutas v√°lidas encontradas:', allRoutes);
            
            if (allRoutes.length === 0) {
                console.warn('‚ö†Ô∏è No se encontraron rutas v√°lidas para ninguna l√≠nea');
                return;
            }
            
            // Si solo hay una ruta, mostrarla normalmente
            if (allRoutes.length === 1) {
                const route = allRoutes[0];
                const routeStops = [];
                
                // Considerar la direcci√≥n para mostrar las paradas en el orden correcto
                const startIdx = Math.min(route.startIndex, route.endIndex);
                const endIdx = Math.max(route.startIndex, route.endIndex);
                
                for (let i = startIdx; i <= endIdx; i++) {
                    const stopId = route.ruta.paradas[i];
                    if (stopsData[stopId]) {
                        routeStops.push(stopsData[stopId]);
                    }
                }
                
                console.log('üìç Mostrando √∫nica ruta disponible');
                displaySingleRouteWithHeader(routeStops, route.lineName, getLineColor(route.lineId));
                displayMapRouteWithColor(routeStops, getLineColor(route.lineId), route.lineName);
                return;
            }
            
            // Si hay m√∫ltiples rutas, verificar si comparten trayecto
            const firstRoute = allRoutes[0];
            let routesShareSamePath = true;
            
            for (let i = 1; i < allRoutes.length; i++) {
                if (!routesSharePath(firstRoute.ruta, allRoutes[i].ruta, currentRoute.originStop, currentRoute.destinationStop)) {
                    routesShareSamePath = false;
                    break;
                }
            }
            
            if (routesShareSamePath) {
                console.log('üìç Las rutas comparten trayecto, mostrando solo la primera');
                // Mostrar solo la primera ruta
                const routeStops = [];
                
                // Considerar la direcci√≥n para mostrar las paradas en el orden correcto
                const startIdx = Math.min(firstRoute.startIndex, firstRoute.endIndex);
                const endIdx = Math.max(firstRoute.startIndex, firstRoute.endIndex);
                
                for (let i = startIdx; i <= endIdx; i++) {
                    const stopId = firstRoute.ruta.paradas[i];
                    if (stopsData[stopId]) {
                        routeStops.push(stopsData[stopId]);
                    }
                }
                
                // Calcular color promedio para rutas compartidas
                const sharedColors = allRoutes.map(route => getLineColor(route.lineId));
                const avgColor = averageColor(sharedColors);
                
                displaySharedRouteWithHeader(routeStops, allRoutes, avgColor);
                displayMapRouteWithColor(routeStops, avgColor, firstRoute.lineName);
            } else {
                console.log('üìç Las rutas tienen trayectos diferentes, mostrando todas');
                // Mostrar todas las rutas diferentes
                displayMultipleRoutes(allRoutes);
            }
        }
        
        // === UTILIDADES DE COLOR ===
        // Convierte un string hex (sin #) a objeto {r,g,b}
        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex.split('').map(x => x + x).join('');
            }
            const num = parseInt(hex, 16);
            return {
                r: (num >> 16) & 255,
                g: (num >> 8) & 255,
                b: num & 255
            };
        }

        // Convierte objeto {r,g,b} a string hex "#RRGGBB"
        function rgbToHex({r, g, b}) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Calcula el color promedio de un array de strings hex
        function averageColor(hexColors) {
            const rgbs = hexColors.map(hexToRgb);
            const n = rgbs.length;
            const avg = {
                r: Math.round(rgbs.reduce((sum, c) => sum + c.r, 0) / n),
                g: Math.round(rgbs.reduce((sum, c) => sum + c.g, 0) / n),
                b: Math.round(rgbs.reduce((sum, c) => sum + c.b, 0) / n)
            };
            return rgbToHex(avg);
        }

        // Determinar la direcci√≥n de una ruta bas√°ndose en su codificaci√≥n
        function determineRouteDirection(ruta, lineId) {
            console.log(`üîç Determinando direcci√≥n de ruta:`, ruta);
            
            // La API codifica las rutas a√±adiendo 00 para ida y 01 para vuelta
            // Por ejemplo: l√≠nea 300, ruta 30000 = ida, ruta 30001 = vuelta
            if (ruta.ruta) {
                const rutaId = ruta.ruta.toString();
                const baseLineId = lineId.toString();
                
                console.log(`üéØ Analizando ruta ID: ${rutaId} para l√≠nea ${baseLineId}`);
                
                // Verificar si la ruta termina en 00 (ida) o 01 (vuelta)
                if (rutaId.endsWith('00')) {
                    console.log(`‚úÖ Ruta ${rutaId} identificada como IDA (termina en 00)`);
                    return 'ida';
                } else if (rutaId.endsWith('01')) {
                    console.log(`‚úÖ Ruta ${rutaId} identificada como VUELTA (termina en 01)`);
                    return 'vuelta';
                }
                
                // Si no coincide con el patr√≥n est√°ndar, intentar determinar por el orden de las paradas
                // Esto es un fallback para casos donde la codificaci√≥n no es est√°ndar
                console.log(`‚ö†Ô∏è Codificaci√≥n de ruta no est√°ndar: ${rutaId}, usando fallback`);
            }
            
            // Fallback: determinar direcci√≥n por el orden de las paradas
            // Para rutas de ida, las paradas van en orden ascendente
            // Para rutas de vuelta, las paradas van en orden descendente
            if (ruta.paradas && ruta.paradas.length > 1) {
                // Comparar las primeras y √∫ltimas paradas para determinar direcci√≥n
                const firstStop = ruta.paradas[0];
                const lastStop = ruta.paradas[ruta.paradas.length - 1];
                
                console.log(`üìç Primera parada: ${firstStop}, √öltima parada: ${lastStop}`);
                
                // Mapeo de paradas conocidas para determinar direcci√≥n
                // Paradas cercanas a casa (origen t√≠pico para ida)
                const homeStops = [42, 43, 44, 87, 88, 89, 90, 358, 553];
                // Paradas lejanas (destino t√≠pico para ida)
                const destinationStops = [139, 28, 385, 134, 482, 29, 99, 130, 131, 132];
                
                const isFirstNearHome = homeStops.includes(firstStop);
                const isLastNearHome = homeStops.includes(lastStop);
                const isFirstDestination = destinationStops.includes(firstStop);
                const isLastDestination = destinationStops.includes(lastStop);
                
                console.log(`üè† Primera parada cerca de casa: ${isFirstNearHome}, √öltima parada cerca de casa: ${isLastNearHome}`);
                console.log(`üéØ Primera parada es destino: ${isFirstDestination}, √öltima parada es destino: ${isLastDestination}`);
                
                if (isFirstNearHome && isLastDestination) {
                    console.log(`‚úÖ Ruta identificada como IDA por patr√≥n de paradas`);
                    return 'ida';
                } else if (isFirstDestination && isLastNearHome) {
                    console.log(`‚úÖ Ruta identificada como VUELTA por patr√≥n de paradas`);
                    return 'vuelta';
                }
            }
            
            // Si no se puede determinar, asumir ida por defecto
            console.log(`‚ö†Ô∏è No se pudo determinar direcci√≥n de ruta, asumiendo ida`);
            return 'ida';
        }

        // Funci√≥n auxiliar para obtener el ID correcto de la l√≠nea
        function getCorrectLineId(route) {
            if (route.apiLineId) {
                return route.apiLineId;
            }
            
            // Mapeo de respaldo desde line a apiLineId
            const lineMapping = {
                '3': '300',
                '3A': '301', 
                '12': '1200',
                '14': '1400'
            };
            
            return lineMapping[route.line] || route.line;
        }

        // Obtener el color de una l√≠nea desde los datos de la API
        function getLineColor(lineId) {
            // Mapeo de colores de l√≠neas basado en los datos de la API
            const lineColors = {
                '100': '#982135', // L√≠nea 1
                '1900': '#E46078', // L√≠nea 1A
                '200': '#FDB515', // L√≠nea 2
                '800': '#FDCB5A', // L√≠nea 2A
                '300': '#C0910F', // L√≠nea 3
                '301': '#D3B255', // L√≠nea 3A
                '400': '#00B17A', // L√≠nea 4
                '500': '#6792BC', // L√≠nea 5
                '600': '#F96B09', // L√≠nea 6
                '601': '#FC9751', // L√≠nea 6A
                '700': '#019FA2', // L√≠nea 7
                '1100': '#F94F8E', // L√≠nea 11
                '1200': '#019F02', // L√≠nea 12
                '1500': '#4DB94C', // L√≠nea 12A
                '1400': '#025BBF', // L√≠nea 14
                '1700': '#A15011', // L√≠nea 17
                '2000': '#982135', // L√≠nea 20
                '2100': '#355787', // L√≠nea 21
                '2200': '#934165', // L√≠nea 22
                '2300': '#8E47AD', // L√≠nea 23
                '2301': '#AE7FC5', // L√≠nea 23A
                '2400': '#056E74', // L√≠nea 24
                '1800': '#35264F', // L√≠nea BUH
                '1801': '#35264F', // L√≠nea BUH
                '2450': '#D61D3F', // L√≠nea UDC
                '2451': '#D61D3F'  // L√≠nea UDC
            };
            
            return lineColors[lineId] || '#2196F3'; // Color por defecto si no se encuentra
        }
        
        // Mostrar m√∫ltiples rutas diferentes
        function displayMultipleRoutes(routes) {
            console.log('üéØ Mostrando m√∫ltiples rutas diferentes:', routes);
            
            // Limpiar capa anterior
            if (routeLayer) {
                routeLayer.clearLayers();
            }
            
            // Si todas las rutas comparten trayecto, usar el color promedio
            let useAverageColor = false;
            let avgColor = '#2196F3';
            if (routes.length > 1) {
                const firstSegment = routes[0].ruta.paradas.slice(routes[0].startIndex, routes[0].endIndex + 1).join(',');
                useAverageColor = routes.every(route => route.ruta.paradas.slice(route.startIndex, route.endIndex + 1).join(',') === firstSegment);
                if (useAverageColor) {
                    const sharedColors = routes.map(route => getLineColor(route.lineId));
                    avgColor = averageColor(sharedColors);
                }
            }
            
            // Mostrar todas las rutas en el mapa
            routes.forEach((route, routeIndex) => {
                console.log(`üé® Debugging color para ruta ${routeIndex}:`);
                console.log(`  - lineId: ${route.lineId}`);
                
                let lineColor = getLineColor(route.lineId);
                if (useAverageColor) lineColor = avgColor;
                console.log(`  - Color final: ${lineColor}`);
                const routeStops = [];
                for (let i = route.startIndex; i <= route.endIndex; i++) {
                    const stopId = route.ruta.paradas[i];
                    if (stopsData[stopId]) {
                        routeStops.push(stopsData[stopId]);
                    }
                }
                displayMapRouteWithColor(routeStops, lineColor, route.lineName, useAverageColor);
            });
            // Mostrar lista de paradas combinada
            displayMultipleStopsList(routes, useAverageColor ? avgColor : null);
        }

        // Mostrar ruta en el mapa con color espec√≠fico
        function displayMapRouteWithColor(stops, color, lineName, isShared) {
            console.log(`üé® Dibujando ruta ${lineName} con color ${color}`);
            if (stops.length === 0) {
                console.log('No hay paradas para mostrar en el mapa');
                return;
            }
            const markers = [];
            stops.forEach((stop, index) => {
                let iconColor = color;
                // Si es trayecto compartido, usar el color promedio tambi√©n en los iconos de origen/destino
                let icon;
                if (stop.id === currentRoute.originStop) {
                    icon = L.divIcon({
                        html: `<div style="background-color: ${iconColor}; color: white; padding: 5px; border-radius: 50%; font-weight: bold; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border: 2px solid #fff;">${stop.id}</div>`,
                        iconSize: [30, 30],
                        className: 'custom-div-icon'
                    });
                } else if (stop.id === currentRoute.destinationStop) {
                    icon = L.divIcon({
                        html: `<div style="background-color: ${iconColor}; color: white; padding: 5px; border-radius: 50%; font-weight: bold; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border: 2px solid #fff;">${stop.id}</div>`,
                        iconSize: [30, 30],
                        className: 'custom-div-icon'
                    });
                } else {
                    icon = L.divIcon({
                        html: `<div style="background-color: ${iconColor}; color: white; padding: 3px; border-radius: 50%; font-weight: bold; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.5);">${stop.id}</div>`,
                        iconSize: [25, 25],
                        className: 'custom-div-icon'
                    });
                }
                const lat = parseFloat(stop.posy);
                const lon = parseFloat(stop.posx);
                const marker = L.marker([lat, lon], { icon }).addTo(routeLayer);
                marker.bindPopup(`<b>${stop.nombre}</b><br>Parada ${stop.id}<br><small>${lineName}</small>`);
                markers.push([lat, lon]);
            });
            // Dibujar l√≠nea de ruta con color espec√≠fico
            if (markers.length > 1) {
                const polyline = L.polyline(markers, { 
                    color: color, 
                    weight: 5,
                    opacity: 0.7
                }).addTo(routeLayer);
                // Ajustar vista del mapa para mostrar todas las rutas
                if (routeLayer.getLayers().length === 1) {
                    map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
                } else {
                    // Si ya hay otras rutas, ajustar para incluir todas
                    const allBounds = L.latLngBounds();
                    routeLayer.eachLayer(layer => {
                        if (layer instanceof L.Polyline) {
                            allBounds.extend(layer.getBounds());
                        }
                    });
                    map.fitBounds(allBounds, { padding: [50, 50] });
                }
                console.log(`Ruta ${lineName} dibujada en el mapa con color ${color}`);
            }
        }

        // Mostrar lista de paradas para m√∫ltiples rutas
        function displayMultipleStopsList(routes, sharedColor) {
            console.log('üìã Mostrando lista de paradas para m√∫ltiples rutas');
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = '';
            if (routes.length === 0) {
                stopsList.innerHTML = '<li class="error">No se encontraron rutas para este recorrido</li>';
                return;
            }
            // Crear encabezado para m√∫ltiples rutas
            const header = document.createElement('li');
            header.className = 'route-header';
            header.innerHTML = `
                <div style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; padding: 15px; border-radius: 8px; margin-bottom: 10px; text-align: center;">
                    <h3 style="margin: 0; font-size: 18px;">üöå M√∫ltiples Rutas Disponibles</h3>
                    <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">${routes.length} rutas diferentes entre ${currentRoute.originName} y ${currentRoute.destinationName}</p>
                </div>
            `;
            stopsList.appendChild(header);
            // Mostrar cada ruta
            routes.forEach((route, routeIndex) => {
                const routeStops = [];
                for (let i = route.startIndex; i <= route.endIndex; i++) {
                    const stopId = route.ruta.paradas[i];
                    if (stopsData[stopId]) {
                        routeStops.push(stopsData[stopId]);
                    }
                }
                // Color de la l√≠nea o color compartido
                let lineColor = getLineColor(route.lineId);
                if (sharedColor) lineColor = sharedColor;
                // Crear encabezado de ruta
                const routeHeader = document.createElement('li');
                routeHeader.className = 'route-section';
                routeHeader.innerHTML = `
                    <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin: 10px 0; border-left: 4px solid ${lineColor};">
                        <h4 style="margin: 0; color: ${lineColor}; font-size: 16px;">üöå L√≠nea ${route.lineName}</h4>
                        <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">${routeStops.length} paradas en el recorrido</p>
                    </div>
                `;
                stopsList.appendChild(routeHeader);
                // Mostrar paradas de esta ruta
                routeStops.forEach((stop, index) => {
                    const li = document.createElement('li');
                    li.className = 'stop-item';
                    if (stop.id === currentRoute.originStop) {
                        li.className += ' origin';
                    } else if (stop.id === currentRoute.destinationStop) {
                        li.className += ' destination';
                    }
                    li.innerHTML = `
                        <div class="stop-info">
                            <span class="stop-number">${stop.id}</span>
                            <span class="stop-name">${stop.nombre}</span>
                        </div>
                    `;
                    stopsList.appendChild(li);
                });
                // Agregar separador entre rutas (excepto para la √∫ltima)
                if (routeIndex < routes.length - 1) {
                    const separator = document.createElement('li');
                    separator.innerHTML = '<hr style="margin: 15px 0; border: none; border-top: 1px solid #e0e0e0;">';
                    stopsList.appendChild(separator);
                }
            });
        }

        // Mostrar lista de paradas para una ruta √∫nica con encabezado
        function displaySingleRouteWithHeader(stops, lineName, lineColor) {
            console.log('üìã Mostrando lista de paradas para ruta √∫nica con encabezado');
            
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = '';
            
            if (stops.length === 0) {
                console.log('No hay paradas para mostrar');
                stopsList.innerHTML = '<li class="error">No se encontraron paradas para este recorrido</li>';
                return;
            }
            
            // Crear encabezado de ruta √∫nica
            const routeHeader = document.createElement('li');
            routeHeader.className = 'route-section';
            routeHeader.innerHTML = `
                <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin: 10px 0; border-left: 4px solid ${lineColor};">
                    <h4 style="margin: 0; color: ${lineColor}; font-size: 16px;">üöå L√≠nea ${lineName}</h4>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">${stops.length} paradas en el recorrido</p>
                </div>
            `;
            stopsList.appendChild(routeHeader);
            
            // Mostrar paradas
            stops.forEach((stop, index) => {
                const li = document.createElement('li');
                li.className = 'stop-item';
                
                if (stop.id === currentRoute.originStop) {
                    li.className += ' origin';
                } else if (stop.id === currentRoute.destinationStop) {
                    li.className += ' destination';
                }
                
                li.innerHTML = `
                    <div class="stop-info">
                        <span class="stop-number">${stop.id}</span>
                        <span class="stop-name">${stop.nombre}</span>
                    </div>
                `;
                stopsList.appendChild(li);
            });
        }

        // Mostrar lista de paradas para rutas compartidas con encabezado
        function displaySharedRouteWithHeader(stops, routes, sharedColor) {
            console.log('üìã Mostrando lista de paradas para rutas compartidas con encabezado');
            
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = '';
            
            if (stops.length === 0) {
                console.log('No hay paradas para mostrar');
                stopsList.innerHTML = '<li class="error">No se encontraron paradas para este recorrido</li>';
                return;
            }
            
            // Crear encabezado para rutas compartidas
            const header = document.createElement('li');
            header.className = 'route-header';
            header.innerHTML = `
                <div style="background: linear-gradient(135deg, #2196F3, #1976D2); color: white; padding: 15px; border-radius: 8px; margin-bottom: 10px; text-align: center;">
                    <h3 style="margin: 0; font-size: 18px;">üöå M√∫ltiples L√≠neas - Recorrido Compartido</h3>
                    <p style="margin: 5px 0 0 0; font-size: 14px; opacity: 0.9;">${routes.length} l√≠neas diferentes: ${routes.map(r => r.lineName).join(', ')}</p>
                </div>
            `;
            stopsList.appendChild(header);
            
            // Crear encabezado de ruta compartida
            const routeHeader = document.createElement('li');
            routeHeader.className = 'route-section';
            routeHeader.innerHTML = `
                <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin: 10px 0; border-left: 4px solid ${sharedColor};">
                    <h4 style="margin: 0; color: ${sharedColor}; font-size: 16px;">üöå L√≠neas ${routes.map(r => r.lineName).join(', ')}</h4>
                    <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">${stops.length} paradas en el recorrido compartido</p>
                </div>
            `;
            stopsList.appendChild(routeHeader);
            
            // Mostrar paradas
            stops.forEach((stop, index) => {
                const li = document.createElement('li');
                li.className = 'stop-item';
                
                if (stop.id === currentRoute.originStop) {
                    li.className += ' origin';
                } else if (stop.id === currentRoute.destinationStop) {
                    li.className += ' destination';
                }
                
                li.innerHTML = `
                    <div class="stop-info">
                        <span class="stop-number">${stop.id}</span>
                        <span class="stop-name">${stop.nombre}</span>
                    </div>
                `;
                stopsList.appendChild(li);
            });
        }

        // Mostrar lista de paradas
        function displayStops(stops) {
            console.log('Iniciando displayStops...');
            console.log('Paradas recibidas:', stops);
            
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = '';
            
            if (stops.length === 0) {
                console.log('No hay paradas para mostrar');
                stopsList.innerHTML = '<li class="error">No se encontraron paradas para este recorrido</li>';
                return;
            }
            
            console.log('Mostrando', stops.length, 'paradas');
            stops.forEach((stop, index) => {
                console.log('Procesando parada:', stop);
                const li = document.createElement('li');
                li.className = 'stop-item';
                
                if (stop.id === currentRoute.originStop) {
                    li.className += ' origin';
                } else if (stop.id === currentRoute.destinationStop) {
                    li.className += ' destination';
                }
                
                li.innerHTML = `${stop.id}. ${stop.nombre}`;
                stopsList.appendChild(li);
            });
            
            console.log('Lista de paradas actualizada');
        }
        
        // Mostrar ruta en el mapa
        function displayMapRoute(stops) {
            console.log('Iniciando displayMapRoute...');
            console.log('Paradas para el mapa:', stops);
            // Limpiar capa anterior
            if (routeLayer) {
                routeLayer.clearLayers();
            }
            if (stops.length === 0) {
                console.log('No hay paradas para mostrar en el mapa');
                return;
            }
            const markers = [];
            // Determinar el color de la l√≠nea o el color promedio si hay varias
            let color = '#2196F3';
            console.log('üîç Debugging color de l√≠nea:');
            console.log('  - currentRoute:', currentRoute);
            
            if (currentRoute && currentRoute.apiLineIds) {
                console.log('  - apiLineIds:', currentRoute.apiLineIds);
                
                if (currentRoute.apiLineIds.length === 1) {
                    const lineId = currentRoute.apiLineIds[0];
                    console.log('  - L√≠nea √∫nica:', lineId);
                    color = getLineColor(lineId);
                    console.log('  - Color final:', color);
                } else if (currentRoute.apiLineIds.length > 1) {
                    // Si hay varias l√≠neas, comprobar si comparten trayecto
                    const allSegments = currentRoute.apiLineIds.map(lineId => {
                        const line = linesData[lineId];
                        if (!line || !line.rutas) return null;
                        // Buscar la ruta que contenga tanto el origen como el destino
                        for (let ruta of line.rutas) {
                            if (ruta.paradas && ruta.paradas.includes(currentRoute.originStop) && ruta.paradas.includes(currentRoute.destinationStop)) {
                                const startIndex = ruta.paradas.indexOf(currentRoute.originStop);
                                const endIndex = ruta.paradas.indexOf(currentRoute.destinationStop);
                                if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {
                                    return ruta.paradas.slice(startIndex, endIndex + 1).join(',');
                                }
                            }
                        }
                        return null;
                    });
                    const firstSegment = allSegments[0];
                    const allShare = allSegments.every(seg => seg === firstSegment);
                    if (allShare) {
                        // Color promedio
                        const sharedColors = currentRoute.apiLineIds.map(lineId => getLineColor(lineId));
                        color = averageColor(sharedColors);
                    } else {
                        // Si no comparten trayecto, usar el color de la primera l√≠nea
                        const lineId = currentRoute.apiLineIds[0];
                        color = getLineColor(lineId);
                    }
                }
            }
            stops.forEach((stop, index) => {
                let iconColor = color;
                let icon;
                if (stop.id === currentRoute.originStop) {
                    icon = L.divIcon({
                        html: `<div style="background-color: ${iconColor}; color: white; padding: 5px; border-radius: 50%; font-weight: bold; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border: 2px solid #fff;">${stop.id}</div>`,
                        iconSize: [30, 30],
                        className: 'custom-div-icon'
                    });
                } else if (stop.id === currentRoute.destinationStop) {
                    icon = L.divIcon({
                        html: `<div style="background-color: ${iconColor}; color: white; padding: 5px; border-radius: 50%; font-weight: bold; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border: 2px solid #fff;">${stop.id}</div>`,
                        iconSize: [30, 30],
                        className: 'custom-div-icon'
                    });
                } else {
                    icon = L.divIcon({
                        html: `<div style="background-color: ${iconColor}; color: white; padding: 3px; border-radius: 50%; font-weight: bold; width: 25px; height: 25px; display: flex; align-items: center; justify-content: center; font-size: 12px; border: 2px solid white; box-shadow: 0 0 3px rgba(0,0,0,0.5);">${stop.id}</div>`,
                        iconSize: [25, 25],
                        className: 'custom-div-icon'
                    });
                }
                const lat = parseFloat(stop.posy);
                const lon = parseFloat(stop.posx);
                const marker = L.marker([lat, lon], { icon }).addTo(routeLayer);
                marker.bindPopup(`<b>${stop.nombre}</b><br>Parada ${stop.id}`);
                markers.push([lat, lon]);
            });
            // Dibujar l√≠nea de ruta
            if (markers.length > 1) {
                const polyline = L.polyline(markers, { 
                    color: color, 
                    weight: 5,
                    opacity: 0.7
                }).addTo(routeLayer);
                // Ajustar vista del mapa
                map.fitBounds(polyline.getBounds(), { padding: [50, 50] });
                console.log('Ruta dibujada en el mapa con color', color);
            }
        }
        
        // Obtener horarios desde la API
        async function getScheduleData() {
            console.log('Iniciando getScheduleData...');
            
            try {
                // Validar que tenemos los datos necesarios
                if (!currentRoute) {
                    console.warn('getScheduleData: currentRoute no est√° definido, saltando petici√≥n');
                    return;
                }
                
                console.log('üîç currentRoute actual:', currentRoute);
                console.log('üìä stopsData disponible:', Object.keys(stopsData).length);
                
                // Manejar rutas combinadas vs individuales
                if (currentRoute.type === 'auto-fastest-combined' || currentRoute.type === 'multi-line-normal') {
                    console.log('üöå Usando getCombinedScheduleData para ruta combinada');
                    await getCombinedScheduleData();
                } else {
                    console.log('üìç Usando getScheduleData para ruta individual');
                    // Ruta individual normal - buscar l√≠neas que conecten las paradas
                    const connectingLines = findLinesConnectingStops(
                        currentRoute.originStop, 
                        currentRoute.destinationStop
                    );
                    
                    console.log('üîç Resultado de findLinesConnectingStops:', connectingLines);
                    
                    if (!connectingLines || connectingLines.lines.length === 0) {
                        console.warn('getScheduleData: No se encontraron l√≠neas que conecten las paradas');
                        console.log('currentRoute actual:', currentRoute);
                        
                        // Mostrar error m√°s espec√≠fico
                        const scheduleInfo = document.getElementById('scheduleInfo');
                        if (scheduleInfo) {
                            scheduleInfo.innerHTML = `
                                <div class="error">
                                    <div style="text-align: center; padding: 20px;">
                                        <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                                        <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">No se encontraron l√≠neas disponibles</div>
                                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">Entre las paradas ${currentRoute.originStop} y ${currentRoute.destinationStop}</div>
                                        <div style="font-size: 12px; color: #999;">Verificando configuraci√≥n de rutas</div>
                                    </div>
                                </div>
                            `;
                        }
                        return;
                    }
                    
                    // Usar la primera l√≠nea disponible
                    const firstLineId = connectingLines.apiLineIds[0];
                    
                    const today = new Date();
                    const fecha = today.toISOString().slice(0, 10).replace(/-/g, '');
                    
                    console.log(`Intentando obtener horarios para l√≠nea ${firstLineId}, fecha: ${fecha}...`);
                    const response = await fetch(`${BACKEND_API}/schedule/${firstLineId}/${fecha}`);
                    
                    if (!response.ok) {
                        throw new Error(`Error al obtener horarios: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    console.log('Datos de horarios recibidos del backend:', data);
                    
                    await displayScheduleInfo(data);
                }
                
            } catch (error) {
                console.error('Error en getScheduleData:', error);
                console.error('Error details:', error.message);
                
                // Mostrar mensaje de error m√°s espec√≠fico en lugar de la tabla fija
                const scheduleInfo = document.getElementById('scheduleInfo');
                if (scheduleInfo) {
                    scheduleInfo.innerHTML = `
                        <div class="error">
                            <div style="text-align: center; padding: 20px;">
                                <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                                <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error al cargar horarios</div>
                                <div style="font-size: 14px; color: #666; margin-bottom: 8px;">${error.message}</div>
                                <div style="font-size: 12px; color: #999;">Verificando conexi√≥n con el servicio</div>
                            </div>
                        </div>
                    `;
                }
            }
        }
        
        // Obtener horarios combinados para rutas con m√∫ltiples l√≠neas
        async function getCombinedScheduleData() {
            console.log('üöå Iniciando getCombinedScheduleData para m√∫ltiples l√≠neas...');
            
            if (!currentRoute.apiLineIds || currentRoute.apiLineIds.length === 0) {
                console.warn('getCombinedScheduleData: No se encontraron apiLineIds');
                console.log('currentRoute actual:', currentRoute);
                return;
            }
            
            const today = new Date();
            const fecha = today.toISOString().slice(0, 10).replace(/-/g, '');
            
            console.log(`Obteniendo horarios para l√≠neas: ${currentRoute.apiLineIds.join(', ')}, fecha: ${fecha}`);
            
            try {
                // Obtener horarios de todas las l√≠neas en paralelo
                const schedulePromises = currentRoute.apiLineIds.map(async (lineId, index) => {
                    try {
                        console.log(`üì° Consultando horarios de l√≠nea ${lineId}...`);
                        const response = await fetch(`${BACKEND_API}/schedule/${lineId}/${fecha}`);
                        
                        if (!response.ok) {
                            throw new Error(`Error ${response.status} para l√≠nea ${lineId}`);
                        }
                        
                        const data = await response.json();
                        console.log(`‚úÖ Horarios recibidos para l√≠nea ${lineId}:`, data);
                        
                        return {
                            lineId: lineId,
                            lineName: currentRoute.lines[index], // Nombre amigable (3, 3A, etc.)
                            data: data
                        };
                    } catch (error) {
                        console.error(`‚ùå Error obteniendo horarios de l√≠nea ${lineId}:`, error);
                        return {
                            lineId: lineId,
                            lineName: currentRoute.lines[index],
                            error: error.message
                        };
                    }
                });
                
                // Esperar a que se resuelvan todas las promesas
                const scheduleResults = await Promise.all(schedulePromises);
                
                console.log('üìä Resultados de horarios combinados:', scheduleResults);
                
                // Filtrar solo los resultados exitosos
                const successfulSchedules = scheduleResults.filter(result => !result.error);
                
                if (successfulSchedules.length === 0) {
                    throw new Error('No se pudieron obtener horarios de ninguna l√≠nea');
                }
                
                // Mostrar horarios combinados
                await displayCombinedScheduleInfo(successfulSchedules);
                
            } catch (error) {
                console.error('Error en getCombinedScheduleData:', error);
                
                // Mostrar mensaje de error
                const scheduleInfo = document.getElementById('scheduleInfo');
                if (scheduleInfo) {
                    scheduleInfo.innerHTML = `
                        <div class="error">
                            <div style="text-align: center; padding: 20px;">
                                <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                                <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error al cargar horarios combinados</div>
                                <div style="font-size: 14px; color: #666; margin-bottom: 8px;">${error.message}</div>
                                <div style="font-size: 12px; color: #999;">Verificando conexi√≥n con el servicio</div>
                            </div>
                        </div>
                    `;
                }
            }
        }
        
        // Mostrar informaci√≥n de horarios combinados para m√∫ltiples l√≠neas
        async function displayCombinedScheduleInfo(scheduleResults) {
            console.log('üéØ Mostrando informaci√≥n de horarios combinados:', scheduleResults);
            
            // Convertir formato HHMM a formato HH:MM
            function formatoHHMMToHora(hhmm) {
                const horas = Math.floor(hhmm / 100);
                const mins = hhmm % 100;
                return `${horas.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            }
            
            // Procesar cada l√≠nea para obtener itinerarios y pr√≥ximos horarios
            const lineSections = [];
            const allNextSchedules = [];
            
            scheduleResults.forEach(result => {
                if (result.data && result.data.servicios && result.data.servicios.length > 0) {
                    const servicio = result.data.servicios[0];
                    const fecha = new Date(servicio.fecha.slice(0, 4), servicio.fecha.slice(4, 6) - 1, servicio.fecha.slice(6, 8));
                    
                    // Determinar si usar horarios de ida o vuelta bas√°ndose en la ruta
                    const esIda = currentRoute.originStop === 42;
                    const horarios = esIda ? servicio.ida : servicio.vuelta;
                    
                    // Obtener todos los horarios del d√≠a y destacar los pr√≥ximos 4
                    const ahora = new Date();
                    const horaActual = ahora.getHours() * 60 + ahora.getMinutes();
                    
                    const todosHorarios = horarios.map(h => {
                        const hora = formatoHHMMToHora(h);
                        const horaHorario = Math.floor(h / 100);
                        const minHorario = h % 100;
                        const minutosHorario = horaHorario * 60 + minHorario;
                        const esProximo = minutosHorario > horaActual;
                        
                        return {
                            hora: hora,
                            minutos: minutosHorario,
                            esProximo: esProximo
                        };
                    });
                    
                    // Filtrar los pr√≥ximos 4 horarios
                    const horariosProximos = todosHorarios.filter(h => h.esProximo).slice(0, 4);
                    
                    // Obtener todas las paradas de la l√≠nea para el itinerario completo
                    let allStops = [];
                    const currentLine = linesData[result.lineId];
                    
                    if (currentLine && currentLine.rutas && currentLine.rutas.length > 0) {
                        // Buscar la ruta que contenga tanto el origen como el destino
                        for (let rutaIndex = 0; rutaIndex < currentLine.rutas.length; rutaIndex++) {
                            const ruta = currentLine.rutas[rutaIndex];
                            
                            if (ruta.paradas) {
                                const stopIds = ruta.paradas;
                                
                                // Verificar si esta ruta corresponde a la direcci√≥n actual
                                const rutaDirection = determineRouteDirection(ruta, result.lineId);
                                
                                if (rutaDirection === currentDirection) {
                                    // Obtener todas las paradas de la l√≠nea
                                    const originIndex = stopIds.indexOf(currentRoute.originStop);
                                    const destinationIndex = stopIds.indexOf(currentRoute.destinationStop);
                                    
                                    for (let i = 0; i < stopIds.length; i++) {
                                        const stopId = stopIds[i];
                                        if (stopsData[stopId]) {
                                            const stop = stopsData[stopId];
                                            // Resaltar todas las paradas del recorrido (incluyendo intermedias)
                                            const isInRoute = (i >= Math.min(originIndex, destinationIndex) && i <= Math.max(originIndex, destinationIndex));
                                            allStops.push({
                                                ...stop,
                                                isInRoute: isInRoute
                                            });
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Obtener el color espec√≠fico de la l√≠nea
                    const lineColor = getLineColor(result.lineId);
                    
                    // Crear itinerario con todas las paradas, resaltando las del recorrido
                    let itinerarioHTML = '';
                    if (allStops.length > 0) {
                        const stopNames = allStops.map(stop => {
                            if (stop.isInRoute) {
                                return `<span class="stop-item-itinerary" style="background: ${lineColor}; color: white; font-weight: bold;">${stop.nombre}</span>`;
                            } else {
                                return `<span class="stop-item-itinerary">${stop.nombre}</span>`;
                            }
                        });
                        itinerarioHTML = stopNames.join('<span class="arrow-separator"> ‚Üí </span>');
                    } else {
                        itinerarioHTML = '<span style="color: #999;">Itinerario no disponible</span>';
                    }
                    
                    // Crear HTML para todos los horarios, destacando los pr√≥ximos
                    let horariosHTML = '';
                    if (todosHorarios.length > 0) {
                        horariosHTML = todosHorarios.map(h => {
                            if (h.esProximo && horariosProximos.some(proximo => proximo.hora === h.hora)) {
                                return `<span class="schedule-time" style="background: ${lineColor}; color: white; font-weight: bold; box-shadow: 0 2px 4px ${lineColor}40;">${h.hora}</span>`;
                            } else {
                                return `<span class="schedule-time">${h.hora}</span>`;
                            }
                        }).join('');
                    } else {
                        horariosHTML = '<span style="color: #999;">No hay horarios disponibles</span>';
                    }
                    
                    // Crear encabezado de horarios con fecha espec√≠fica
                    const fechaFormateada = fecha.toLocaleDateString('es-ES', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    }).replace(/^\w/, c => c.toUpperCase());
                    
                    // Obtener el nombre de la l√≠nea con origen y destino reales
                    let lineTitle = `L√≠nea ${result.lineName}: ${currentRoute.originName} ‚Üí ${currentRoute.destinationName}`; // Fallback
                    
                    // Obtener el origen y destino reales de la l√≠nea completa
                    if (currentLine && currentLine.rutas && currentLine.rutas.length > 0) {
                        // Buscar la ruta que corresponda a la direcci√≥n actual
                        for (let rutaIndex = 0; rutaIndex < currentLine.rutas.length; rutaIndex++) {
                            const ruta = currentLine.rutas[rutaIndex];
                            
                            if (ruta.paradas && ruta.paradas.length > 0) {
                                const rutaDirection = determineRouteDirection(ruta, result.lineId);
                                
                                if (rutaDirection === currentDirection) {
                                    // Obtener primera y √∫ltima parada de la l√≠nea completa
                                    const firstStopId = ruta.paradas[0];
                                    const lastStopId = ruta.paradas[ruta.paradas.length - 1];
                                    
                                    const firstStop = stopsData[firstStopId];
                                    const lastStop = stopsData[lastStopId];
                                    
                                    if (firstStop && lastStop) {
                                        lineTitle = `L√≠nea ${result.lineName}: ${firstStop.nombre} ‚Üí ${lastStop.nombre}`;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Agregar secci√≥n de l√≠nea
                    lineSections.push(`
                        <div class="line-section" style="border-left: 4px solid ${lineColor};">
                            <div class="line-title">${lineTitle}</div>
                            
                            <div class="line-subsection" style="border-left: 3px solid ${lineColor};">
                                <div class="subsection-title">üïê Horarios de salidas desde cabecera del ${fechaFormateada}</div>
                                <div class="next-schedules">
                                    ${horariosHTML}
                                </div>
                            </div>
                            
                            <div class="line-subsection" style="border-left: 3px solid ${lineColor};">
                                <div class="subsection-title">üìç Itinerario</div>
                                <div class="itinerary-stops">
                                    ${itinerarioHTML}
                                </div>
                            </div>
                        </div>
                    `);
                    
                    // Agregar a pr√≥ximos horarios globales
                    horariosProximos.forEach(h => {
                        allNextSchedules.push({
                            hora: h.hora,
                            lineName: result.lineName,
                            lineId: result.lineId,
                            minutos: h.minutos
                        });
                    });
                }
            });
            
            if (lineSections.length === 0) {
                const scheduleInfo = document.getElementById('scheduleInfo');
                scheduleInfo.innerHTML = `
                    <div class="error">
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">üìÖ</div>
                            <div style="font-size: 16px; color: #666; margin-bottom: 10px;">No hay horarios disponibles</div>
                            <div style="font-size: 14px; color: #999;">Para las l√≠neas ${scheduleResults.map(r => r.lineName).join(' y ')}</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Ordenar pr√≥ximos horarios por tiempo
            allNextSchedules.sort((a, b) => a.minutos - b.minutos);
            
            // Definir lineInfo antes de usarlo en el HTML

            
            // Generar t√≠tulo espec√≠fico para la cabecera
            let headerTitle = '';
            if (scheduleResults.length === 1) {
                headerTitle = `M√°s informaci√≥n de la l√≠nea ${scheduleResults[0].lineName}`;
            } else {
                const lineNames = scheduleResults.map(r => r.lineName);
                headerTitle = `M√°s informaci√≥n de las l√≠neas ${lineNames.join(' y ')}`;
            }
            
            const scheduleInfo = document.getElementById('scheduleInfo');
            scheduleInfo.innerHTML = `
                <div class="info-section">
                    <div class="info-header" onclick="toggleInfoSection()">
                        <span>üìã ${headerTitle}</span>
                        <span class="info-toggle">‚ñº</span>
                    </div>
                    <div class="info-content" id="infoContent">
                        ${lineSections.join('')}
                    </div>
                </div>
            `;
        }
        
        // Obtener tiempo de llegada en tiempo real
        async function getArrivalTime() {
            console.log('Iniciando getArrivalTime...');
            
            try {
                // Validar que tenemos los datos necesarios
                if (!currentRoute || !currentRoute.originStop) {
                    console.warn('getArrivalTime: currentRoute.originStop no est√° definido, saltando petici√≥n');
                    console.log('currentRoute actual:', currentRoute);
                    return;
                }
                
                // Los enlaces no tienen estado disabled, pero podemos deshabilitarlos visualmente
                const updateLink = document.querySelector('a[onclick*="updateArrivalTime"]');
                if (updateLink) updateLink.style.pointerEvents = 'none';
                
                console.log(`Intentando con backend para llegadas de parada ${currentRoute.originStop}...`);
                const response = await fetch(`${BACKEND_API}/arrivals/${currentRoute.originStop}`);
                
                if (!response.ok) {
                    throw new Error(`Error al obtener tiempos: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Datos de llegada recibidos del backend:', data);
                
                // Manejar rutas combinadas vs individuales
                if (currentRoute.type === 'auto-fastest-combined' || currentRoute.type === 'multi-line-normal') {
                    displayCombinedArrivalTimes(data);
                } else {
                    displayArrivalTimes(data);
                }
                
                // Actualizar t√≠tulo despu√©s de cargar los datos
                updateArrivalTitle();
                
            } catch (error) {
                console.error('Error en getArrivalTime:', error);
                console.error('Error details:', error.message);
                // Solo mostrar error en la secci√≥n de llegadas, no limpiar todo el cach√©
                showArrivalError();
            } finally {
                // Rehabilitar el enlace
                const updateLink = document.querySelector('a[onclick*="updateArrivalTime"]');
                if (updateLink) updateLink.style.pointerEvents = 'auto';
            }
        }
        
        // Mostrar informaci√≥n de horarios
        async function displayScheduleInfo(data) {
            const scheduleInfo = document.getElementById('scheduleInfo');
            
            if (!data || !data.servicios || data.servicios.length === 0) {
                scheduleInfo.innerHTML = `
                    <div class="error">
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                            <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">No se pudieron cargar los horarios para hoy</div>
                            <div style="font-size: 14px; color: #999;">Verificando conexi√≥n con el servicio</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Almacenar datos de horarios globalmente para actualizaciones posteriores
            window.lastScheduleData = data;
            
            const servicio = data.servicios[0];
            const fecha = new Date(servicio.fecha.slice(0, 4), servicio.fecha.slice(4, 6) - 1, servicio.fecha.slice(6, 8));
            const tipoDia = servicio.tipo;
            
            // Convertir formato HHMM a formato HH:MM
            function formatoHHMMToHora(hhmm) {
                const horas = Math.floor(hhmm / 100);
                const mins = hhmm % 100;
                return `${horas.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
            }
            
            // Buscar l√≠neas que conecten las paradas para obtener el nombre
            const connectingLines = findLinesConnectingStops(
                currentRoute.originStop, 
                currentRoute.destinationStop
            );
            
            // Obtener el nombre de la l√≠nea con origen y destino reales
            let nombreLinea = `${currentRoute.originName} ‚Üí ${currentRoute.destinationName}`; // Fallback
            
            // Obtener el origen y destino reales de la l√≠nea completa
            if (connectingLines && connectingLines.apiLineIds.length > 0) {
                const firstLineId = connectingLines.apiLineIds[0];
                const currentLine = linesData[firstLineId];
                
                if (currentLine && currentLine.rutas && currentLine.rutas.length > 0) {
                    // Buscar la ruta que corresponda a la direcci√≥n actual
                    for (let rutaIndex = 0; rutaIndex < currentLine.rutas.length; rutaIndex++) {
                        const ruta = currentLine.rutas[rutaIndex];
                        
                        if (ruta.paradas && ruta.paradas.length > 0) {
                            const rutaDirection = determineRouteDirection(ruta, firstLineId);
                            
                            if (rutaDirection === currentDirection) {
                                // Obtener primera y √∫ltima parada de la l√≠nea completa
                                const firstStopId = ruta.paradas[0];
                                const lastStopId = ruta.paradas[ruta.paradas.length - 1];
                                
                                const firstStop = stopsData[firstStopId];
                                const lastStop = stopsData[lastStopId];
                                
                                if (firstStop && lastStop) {
                                    nombreLinea = `L√≠nea ${connectingLines.lineNames[0]}: ${firstStop.nombre} ‚Üí ${lastStop.nombre}`;
                                }
                                break;
                            }
                        }
                    }
                }
            }
            
            // Determinar si usar horarios de ida o vuelta bas√°ndose en el campo direction
            const esIda = currentRoute.direction === 'ida';
            const horarios = esIda ? servicio.ida : servicio.vuelta;
            
            // Calcular horarios pr√≥ximos bas√°ndose en la hora actual
            const ahora = new Date();
            const horaActual = ahora.getHours() * 60 + ahora.getMinutes(); // minutos desde medianoche
            
            // Obtener todos los horarios del d√≠a y destacar los pr√≥ximos 4
            const todosHorarios = horarios.map(h => {
                const hora = formatoHHMMToHora(h);
                const horaHorario = Math.floor(h / 100);
                const minHorario = h % 100;
                const minutosHorario = horaHorario * 60 + minHorario;
                const esProximo = minutosHorario > horaActual;
                
                return {
                    hora: hora,
                    minutos: minutosHorario,
                    esProximo: esProximo
                };
            });
            
            // Filtrar los pr√≥ximos 4 horarios
            const horariosProximos = todosHorarios.filter(h => h.esProximo).slice(0, 4);
            
            // Obtener todas las paradas de la l√≠nea para el itinerario completo
            let allStops = [];
            if (connectingLines && connectingLines.apiLineIds.length > 0) {
                const firstLineId = connectingLines.apiLineIds[0];
                const currentLine = linesData[firstLineId];
                
                if (currentLine && currentLine.rutas && currentLine.rutas.length > 0) {
                    // Buscar la ruta que contenga tanto el origen como el destino
                    for (let rutaIndex = 0; rutaIndex < currentLine.rutas.length; rutaIndex++) {
                        const ruta = currentLine.rutas[rutaIndex];
                        
                        if (ruta.paradas) {
                            const stopIds = ruta.paradas;
                            
                            // Verificar si esta ruta corresponde a la direcci√≥n actual
                            const rutaDirection = determineRouteDirection(ruta, firstLineId);
                            
                            if (rutaDirection === currentDirection) {
                                // Obtener todas las paradas de la l√≠nea
                                const originIndex = stopIds.indexOf(currentRoute.originStop);
                                const destinationIndex = stopIds.indexOf(currentRoute.destinationStop);
                                
                                for (let i = 0; i < stopIds.length; i++) {
                                    const stopId = stopIds[i];
                                    if (stopsData[stopId]) {
                                        const stop = stopsData[stopId];
                                        // Resaltar todas las paradas del recorrido (incluyendo intermedias)
                                        const isInRoute = (i >= Math.min(originIndex, destinationIndex) && i <= Math.max(originIndex, destinationIndex));
                                        allStops.push({
                                            ...stop,
                                            isInRoute: isInRoute
                                        });
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            }
            
            // Obtener el color espec√≠fico de la l√≠nea
            console.log('üîç Debug color - apiLineId:', currentRoute.apiLineId, 'line:', currentRoute.line);
            console.log('üîç Debug color - currentRoute completo:', currentRoute);
            
            // Usar el ID de la l√≠nea que ya obtuvimos desde connectingLines
            let lineId = null;
            if (connectingLines && connectingLines.apiLineIds.length > 0) {
                lineId = connectingLines.apiLineIds[0]; // Mismo ID que usamos para firstLineId
            } else {
                // Usar la funci√≥n auxiliar como respaldo
                lineId = getCorrectLineId(currentRoute);
            }
            const lineColor = getLineColor(lineId);
            console.log('üîç Debug color - ID usado:', lineId, 'Color obtenido:', lineColor);
            
            // Crear itinerario con todas las paradas, resaltando las del recorrido
            let itinerarioHTML = '';
            if (allStops.length > 0) {
                const stopNames = allStops.map(stop => {
                    if (stop.isInRoute) {
                        return `<span class="stop-item-itinerary" style="background: ${lineColor}; color: white; font-weight: bold;">${stop.nombre}</span>`;
                    } else {
                        return `<span class="stop-item-itinerary">${stop.nombre}</span>`;
                    }
                });
                itinerarioHTML = stopNames.join('<span class="arrow-separator"> ‚Üí </span>');
            } else {
                itinerarioHTML = '<span style="color: #999;">Itinerario no disponible</span>';
            }
            
            // Crear HTML para todos los horarios, destacando los pr√≥ximos
            let horariosHTML = '';
            if (todosHorarios.length > 0) {
                horariosHTML = todosHorarios.map(h => {
                    if (h.esProximo && horariosProximos.some(proximo => proximo.hora === h.hora)) {
                        return `<span class="schedule-time" style="background: ${lineColor}; color: white; font-weight: bold; box-shadow: 0 2px 4px ${lineColor}40;">${h.hora}</span>`;
                    } else {
                        return `<span class="schedule-time">${h.hora}</span>`;
                    }
                }).join('');
            } else {
                horariosHTML = '<span style="color: #999;">No hay horarios disponibles</span>';
            }
            
            // Crear encabezado de horarios con fecha espec√≠fica
            const fechaFormateada = fecha.toLocaleDateString('es-ES', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            }).replace(/^\w/, c => c.toUpperCase());
            

            
            // Generar t√≠tulo espec√≠fico para la cabecera
            let headerTitle = '';
            if (connectingLines && connectingLines.lineNames.length > 0) {
                if (connectingLines.lineNames.length === 1) {
                    headerTitle = `M√°s informaci√≥n de la l√≠nea ${connectingLines.lineNames[0]}`;
                } else {
                    headerTitle = `M√°s informaci√≥n de las l√≠neas ${connectingLines.lineNames.join(' y ')}`;
                }
            } else {
                headerTitle = 'M√°s informaci√≥n de las l√≠neas disponibles';
            }
            
            scheduleInfo.innerHTML = `
                <div class="info-section">
                    <div class="info-header" onclick="toggleInfoSection()">
                        <span>üìã ${headerTitle}</span>
                        <span class="info-toggle">‚ñº</span>
                    </div>
                    <div class="info-content" id="infoContent">
                        <div class="line-section" style="border-left: 4px solid ${lineColor};">
                            <div class="line-title">${nombreLinea}</div>
                            
                            <div class="line-subsection" style="border-left: 3px solid ${lineColor};">
                                <div class="subsection-title">üïê Horarios de salidas desde cabecera del ${fechaFormateada}</div>
                                <div class="next-schedules">
                                    ${horariosHTML}
                                </div>
                            </div>
                            
                            <div class="line-subsection" style="border-left: 3px solid ${lineColor};">
                                <div class="subsection-title">üìç Itinerario</div>
                                <div class="itinerary-stops">
                                    ${itinerarioHTML}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Funci√≥n para alternar la secci√≥n de informaci√≥n
        function toggleInfoSection() {
            const infoContent = document.getElementById('infoContent');
            const infoToggle = document.querySelector('.info-toggle');
            
            if (infoContent && infoToggle) {
                if (infoContent.classList.contains('expanded')) {
                    // Colapsar
                    infoContent.classList.remove('expanded');
                    infoToggle.textContent = '‚ñº';
                    infoToggle.style.transform = 'rotate(0deg)';
                } else {
                    // Expandir
                    infoContent.classList.add('expanded');
                    infoToggle.textContent = '‚ñ≤';
                    infoToggle.style.transform = 'rotate(180deg)';
                }
            }
        }
        
        // Funci√≥n para alternar la secci√≥n de horarios (mantener para compatibilidad)
        function toggleScheduleSection() {
            const scheduleContent = document.querySelector('.schedule-content');
            const scheduleToggle = document.querySelector('.schedule-toggle');
            
            if (scheduleContent && scheduleToggle) {
                if (scheduleContent.style.display === 'none') {
                    // Desplegar
                    scheduleContent.style.display = 'block';
                    scheduleToggle.textContent = '‚ñ≤';
                    scheduleToggle.style.color = 'white';
                } else {
                    // Colapsar
                    scheduleContent.style.display = 'none';
                    scheduleToggle.textContent = '‚ñº';
                    scheduleToggle.style.color = 'white';
                }
            }
        }
        
        // Mostrar tiempos de llegada
        function displayArrivalTimes(data) {
            const arrivalsList = document.getElementById('arrivalsList');
            arrivalsList.innerHTML = '';
            
            // A√±adir estilos para rutas combinadas si no existen (igual que en displayCombinedArrivalTimes)
            if (!document.querySelector('#combined-arrival-styles')) {
                const styles = document.createElement('style');
                styles.id = 'combined-arrival-styles';
                styles.textContent = `
                    .arrival-item.combined {
                        border-left: 4px solid #2196F3;
                        position: relative;
                    }
                    
                    .arrival-line {
                        color: white !important;
                        font-weight: bold;
                        padding: 2px 8px;
                        border-radius: 12px;
                        font-size: 12px;
                        display: inline-block;
                        min-width: 50px;
                        text-align: center;
                    }
                    
                    .next-bus-badge {
                        background: linear-gradient(135deg, #4CAF50, #45a049);
                        color: white;
                        font-size: 10px;
                        padding: 2px 6px;
                        border-radius: 8px;
                        margin-top: 4px;
                        display: inline-block;
                        font-weight: bold;
                    }
                `;
                document.head.appendChild(styles);
            }
            
            if (!data || !data.buses || !data.buses.lineas) {
                arrivalsList.innerHTML = '<div class="error">No se pudieron cargar los datos de llegada</div>';
                return;
            }
            
            // Buscar l√≠neas que conecten las paradas
            const connectingLines = findLinesConnectingStops(
                currentRoute.originStop, 
                currentRoute.destinationStop
            );
            
            if (!connectingLines || connectingLines.lines.length === 0) {
                arrivalsList.innerHTML = '<div class="error">No se encontraron l√≠neas que conecten las paradas</div>';
                return;
            }
            
            // Filtrar solo las l√≠neas que conectan las paradas
            const currentLineArrivals = [];
            const allLines = [];
            
            data.buses.lineas.forEach(linea => {
                // Mostrar informaci√≥n de todas las l√≠neas para debug
                allLines.push(`L√≠nea ${linea.linea}: ${linea.buses ? linea.buses.length : 0} buses`);
                
                                        // Verificar si esta l√≠nea conecta las paradas
                        if (connectingLines.apiLineIds.includes(linea.linea.toString())) {
                            if (linea.buses) {
                                linea.buses.forEach(bus => {
                                    // Encontrar el nombre de la l√≠nea
                                    const lineIndex = connectingLines.apiLineIds.indexOf(linea.linea.toString());
                                    let lineName;
                                    
                                    if (lineIndex !== -1 && connectingLines.lineNames[lineIndex]) {
                                        lineName = connectingLines.lineNames[lineIndex];
                                    } else {
                                        lineName = `L√≠nea ${linea.linea}`;
                                    }
                                    
                                    console.log(`üîç Buscando l√≠nea ${linea.linea}:`, {
                                        lineIndex,
                                        lineName,
                                        availableLineNames: connectingLines.lineNames,
                                        availableApiLineIds: connectingLines.apiLineIds
                                    });
                                    
                                    currentLineArrivals.push({
                                        line: lineName,
                                        minutes: parseInt(bus.tiempo),
                                        destination: currentRoute.destinationName,
                                        busId: bus.bus
                                    });
                                });
                            }
                        }
            });
            
            if (currentLineArrivals.length === 0) {
                const lineNames = connectingLines.lineNames.join(', ');
                arrivalsList.innerHTML = `
                    <div class="arrival-item">
                        <div style="color: #666; margin-bottom: 10px;">
                            <strong>No hay buses de las L√≠neas ${lineNames} en este momento</strong><br>
                            <div style="margin-top: 5px; font-size: 14px; color: #999;">
                                Direcci√≥n: ${currentRoute.originName} ‚Üí ${currentRoute.destinationName}
                            </div>
                        </div>
                        <div style="font-size: 14px; color: #999; margin-top: 10px;">
                            Los buses de las L√≠neas ${lineNames} pasan por esta parada pero no hay ninguno pr√≥ximo.
                            <br><small>L√≠neas disponibles en la parada: ${allLines.join(', ')}</small>
                        </div>
                    </div>
                `;
            } else {
                // Ordenar por tiempo
                currentLineArrivals.sort((a, b) => a.minutes - b.minutes);
                
                // Mostrar los pr√≥ximos 3 buses
                currentLineArrivals.slice(0, 3).forEach((arrival, index) => {
                    const div = document.createElement('div');
                    div.className = 'arrival-item combined';
                    
                    const timeText = arrival.minutes === 0 ? 'Llegando' : 
                                   arrival.minutes === 1 ? '1 minuto' : 
                                   `${arrival.minutes} minutos`;
                    
                    // Color espec√≠fico para cada l√≠nea
                    let lineColor = '#2196F3'; // Azul por defecto
                    if (arrival.line === '3') lineColor = '#8D6E63'; // Marr√≥n para l√≠nea 3
                    else if (arrival.line === '3A') lineColor = '#BCAAA4'; // Marr√≥n claro para l√≠nea 3A
                    else if (arrival.line === '12') lineColor = '#388E3C'; // Verde para l√≠nea 12
                    else if (arrival.line === '14') lineColor = '#2196F3'; // Azul para l√≠nea 14
                    
                    console.log(`üìã Mostrando arrival:`, arrival);
                    div.innerHTML = `
                        <div>
                            <div class="arrival-line" style="background-color: ${lineColor};">
                                L√≠nea ${arrival.line}
                            </div>
                            ${index === 0 ? '<div class="next-bus-badge">Pr√≥ximo</div>' : ''}
                        </div>
                        <div class="arrival-time">${timeText}</div>
                    `;
                    
                    arrivalsList.appendChild(div);
                });
            }
            
            // Actualizar hora
            const updateTime = document.getElementById('updateTime');
            const now = new Date();
            updateTime.innerHTML = `
                <div style="text-align: center; padding: 8px; font-size: 14px; color: #666;">
                    <span style="color: #2196F3; margin-right: 5px;">üïê</span>
                    <span style="font-weight: bold; color: #1976D2;">√öltima actualizaci√≥n:</span>
                    <span style="font-weight: bold; color: #333; margin: 0 5px;">
                        ${now.toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'})}
                    </span>
                    <span style="color: #999;">
                        ${now.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'})}
                    </span>
                </div>
            `;
        }
        
        // Mostrar tiempos de llegada para rutas combinadas (m√∫ltiples l√≠neas)
        function displayCombinedArrivalTimes(data) {
            const arrivalsList = document.getElementById('arrivalsList');
            arrivalsList.innerHTML = '';
            
            if (!data || !data.buses || !data.buses.lineas) {
                arrivalsList.innerHTML = '<div class="error">No se pudieron cargar los datos de llegada</div>';
                return;
            }
            
            // Recopilar buses de todas las l√≠neas objetivo
            const combinedArrivals = [];
            const availableLines = [];
            
            data.buses.lineas.forEach(linea => {
                // Mostrar informaci√≥n de todas las l√≠neas para debug
                availableLines.push(`L√≠nea ${linea.linea}: ${linea.buses ? linea.buses.length : 0} buses`);
                
                // Verificar si esta l√≠nea est√° en nuestras l√≠neas objetivo
                if (currentRoute.apiLineIds && currentRoute.apiLineIds.includes(linea.linea.toString())) {
                    if (linea.buses) {
                        linea.buses.forEach(bus => {
                            // Convertir ID de API a nombre de l√≠nea legible
                            let lineName = linea.linea.toString();
                            if (linea.linea === 300) lineName = '3';
                            else if (linea.linea === 301) lineName = '3A';
                            else if (linea.linea === 1200) lineName = '12';
                            else if (linea.linea === 1400) lineName = '14';
                            
                            combinedArrivals.push({
                                line: lineName,
                                apiLineId: linea.linea,
                                minutes: parseInt(bus.tiempo),
                                destination: currentRoute.destinationName,
                                busId: bus.bus
                            });
                        });
                    }
                }
            });
            
            if (combinedArrivals.length === 0) {
                arrivalsList.innerHTML = `
                    <div class="arrival-item">
                        <div style="color: #666; margin-bottom: 10px;">
                            <strong>No hay buses de ${currentRoute.combinedName} en este momento</strong><br>
                            <div style="margin-top: 5px; font-size: 14px; color: #999;">
                                Direcci√≥n: ${currentRoute.originName} ‚Üí ${currentRoute.destinationName}
                            </div>
                        </div>
                        <div style="font-size: 14px; color: #999; margin-top: 10px;">
                            Las l√≠neas ${currentRoute.lineNames ? currentRoute.lineNames.join(', ') : 'objetivo'} pasan por esta parada pero no hay ninguno pr√≥ximo.
                            <br><small>L√≠neas disponibles en la parada: ${availableLines.join(', ')}</small>
                        </div>
                    </div>
                `;
            } else {
                // Ordenar todos los buses por tiempo, independientemente de la l√≠nea
                combinedArrivals.sort((a, b) => a.minutes - b.minutes);
                
                console.log('üöå Buses combinados ordenados:', combinedArrivals);
                
                // Mostrar los pr√≥ximos 5 buses (m√°s que en rutas individuales porque hay m√°s l√≠neas)
                combinedArrivals.slice(0, 5).forEach((arrival, index) => {
                    const div = document.createElement('div');
                    div.className = 'arrival-item combined';
                    
                    const timeText = arrival.minutes === 0 ? 'Llegando' : 
                                   arrival.minutes === 1 ? '1 minuto' : 
                                   `${arrival.minutes} minutos`;
                    
                    // Color espec√≠fico para cada l√≠nea
                    let lineColor = '#2196F3'; // Azul por defecto
                    if (arrival.line === '3') lineColor = '#8D6E63'; // Marr√≥n para l√≠nea 3
                    else if (arrival.line === '3A') lineColor = '#BCAAA4'; // Marr√≥n claro para l√≠nea 3A
                    else if (arrival.line === '12') lineColor = '#388E3C'; // Verde para l√≠nea 12
                    else if (arrival.line === '14') lineColor = '#2196F3'; // Azul para l√≠nea 14
                    
                    div.innerHTML = `
                        <div>
                            <div class="arrival-line" style="background-color: ${lineColor};">
                                L√≠nea ${arrival.line}
                            </div>
                            ${index === 0 ? '<div class="next-bus-badge">Pr√≥ximo</div>' : ''}
                        </div>
                        <div class="arrival-time">${timeText}</div>
                    `;
                    
                    arrivalsList.appendChild(div);
                });
                
                // A√±adir estilos para rutas combinadas si no existen
                if (!document.querySelector('#combined-arrival-styles')) {
                    const styles = document.createElement('style');
                    styles.id = 'combined-arrival-styles';
                    styles.textContent = `
                        .arrival-item.combined {
                            border-left: 4px solid #2196F3;
                            position: relative;
                        }
                        
                        .arrival-line {
                            color: white !important;
                            font-weight: bold;
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 12px;
                            display: inline-block;
                            min-width: 50px;
                            text-align: center;
                        }
                        
                        .next-bus-badge {
                            background: linear-gradient(135deg, #4CAF50, #45a049);
                            color: white;
                            font-size: 10px;
                            padding: 2px 6px;
                            border-radius: 8px;
                            margin-top: 4px;
                            display: inline-block;
                            font-weight: bold;
                        }
                    `;
                    document.head.appendChild(styles);
                }
            }
            
            // Actualizar hora
            const updateTime = document.getElementById('updateTime');
            const now = new Date();
            updateTime.innerHTML = `
                <div style="text-align: center; padding: 8px; font-size: 14px; color: #666;">
                    <span style="color: #2196F3; margin-right: 5px;">üïê</span>
                    <span style="font-weight: bold; color: #1976D2;">√öltima actualizaci√≥n:</span>
                    <span style="font-weight: bold; color: #333; margin: 0 5px;">
                        ${now.toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'})}
                    </span>
                    <span style="color: #999;">
                        ${now.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'})}
                    </span>
                </div>
            `;
        }
        
        // Mostrar error cuando no se pueden cargar los datos
        function showConnectionError() {
            // Limpiar cach√© en caso de error
            linesData = {};
            stopsData = {};
            
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = `
                <li class="error">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚ùå</div>
                        <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error de conexi√≥n</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">No se pudo conectar con el servicio de autobuses</div>
                        <div style="font-size: 12px; color: #999;">Verifica tu conexi√≥n a internet e intenta de nuevo</div>
                    </div>
                </li>
            `;
            
            const arrivalsList = document.getElementById('arrivalsList');
            arrivalsList.innerHTML = `
                <div class="error">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚ùå</div>
                        <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error de conexi√≥n</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">No se pueden cargar los tiempos de llegada</div>
                        <div style="font-size: 12px; color: #999;">Comprueba tu conexi√≥n a internet</div>
                    </div>
                </div>
            `;
            
            // No dibujar nada en el mapa
            if (routeLayer) {
                routeLayer.clearLayers();
            }
        }
        
        // Mostrar error solo en la secci√≥n de llegadas (sin limpiar cach√©)
        function showArrivalError() {
            const arrivalsList = document.getElementById('arrivalsList');
            arrivalsList.innerHTML = `
                <div class="error">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚ö†Ô∏è</div>
                        <div style="font-size: 16px; color: #f57c00; margin-bottom: 10px;">Error temporal de conexi√≥n</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">No se pudieron actualizar los tiempos de llegada</div>
                        <div style="font-size: 12px; color: #999;">Se reintentar√° autom√°ticamente en 2 minutos</div>
                        <div style="margin-top: 10px;">
                            <button onclick="getArrivalTime()" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                Reintentar ahora
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        

        
        // Mostrar error espec√≠fico de CORS
        function showCorsError() {
            // Limpiar cach√© en caso de error
            linesData = {};
            stopsData = {};
            
            const stopsList = document.getElementById('stopsList');
            stopsList.innerHTML = `
                <li class="error">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üö´</div>
                        <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error de CORS</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">La API no permite peticiones desde el navegador</div>
                        <div style="font-size: 12px; color: #999;">Problema de configuraci√≥n del servidor</div>
                    </div>
                </li>
            `;
            
            const arrivalsList = document.getElementById('arrivalsList');
            arrivalsList.innerHTML = `
                <div class="error">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üö´</div>
                        <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error de CORS</div>
                        <div style="font-size: 14px; color: #666; margin-bottom: 8px;">La API no permite peticiones desde el navegador</div>
                        <div style="font-size: 12px; color: #999;">Problema de configuraci√≥n del servidor</div>
                    </div>
                </div>
            `;
            
            // No dibujar nada en el mapa
            if (routeLayer) {
                routeLayer.clearLayers();
            }
        }
        
        // Actualizar tiempo de llegada
        function updateArrivalTime() {
            document.getElementById('arrivalsList').innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üîÑ</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Actualizando...</div>
                        <div style="font-size: 14px; color: #999;">Obteniendo datos m√°s recientes</div>
                    </div>
                </div>
            `;
            getArrivalTime();
        }
        
        // Funci√≥n para limpiar completamente la cach√©
        function clearCache() {
            console.log('Limpiando cach√© completa...');
            linesData = {};
            stopsData = {};
            
            // Limpiar mapa
            if (routeLayer) {
                routeLayer.clearLayers();
            }
            
            // Limpiar todas las secciones con estados de carga apropiados
            const stopsList = document.getElementById('stopsList');
            const arrivalsList = document.getElementById('arrivalsList');
            const scheduleInfo = document.getElementById('scheduleInfo');
            
            if (stopsList) stopsList.innerHTML = `
                <li class="loading">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 20px; margin-bottom: 8px;">üìç</div>
                        <div style="font-size: 16px; color: #666;">Cargando paradas...</div>
                    </div>
                </li>
            `;
            if (arrivalsList) arrivalsList.innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üöå</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Cargando tiempos de llegada...</div>
                        <div style="font-size: 14px; color: #999;">Conectando con el servicio en tiempo real</div>
                    </div>
                </div>
            `;
            if (scheduleInfo) scheduleInfo.innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚è≥</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Cargando horarios...</div>
                        <div style="font-size: 14px; color: #999;">Obteniendo informaci√≥n actualizada</div>
                    </div>
                </div>
            `;
            
            console.log('Cach√© limpiada completamente');
        }
        
        // Funci√≥n para recargar configuraci√≥n de rutas
        async function reloadRoutesConfig() {
            console.log('üîÑ Recargando configuraci√≥n de rutas...');
            console.log('üìä Estado actual de rutas:', routesConfig);
            
            // Deshabilitar enlaces durante la recarga
            const reloadLink = document.querySelector('a[onclick*="reloadRoutesConfig"]');
            if (reloadLink) reloadLink.style.pointerEvents = 'none';
            
            try {
                // Recargar configuraci√≥n de rutas forzando la recarga
                await loadRoutesConfig(true);
                
                // Recargar datos con la nueva configuraci√≥n
                console.log('üßπ Limpiando cach√©...');
                clearCache();
                console.log('üì° Recargando datos generales...');
                await getGeneralData();
                console.log('üìÖ Recargando horarios...');
                getScheduleData();
                console.log('‚è±Ô∏è Recargando tiempos de llegada...');
                getArrivalTime();
                
                console.log('‚úÖ Configuraci√≥n de rutas recargada correctamente');
                console.log('üìä Nuevo estado de rutas:', routesConfig);
            } catch (error) {
                console.error('Error recargando configuraci√≥n de rutas:', error);
            } finally {
                // Rehabilitar enlaces despu√©s de la recarga
                setTimeout(() => {
                    if (reloadLink) reloadLink.style.pointerEvents = 'auto';
                }, 2000);
            }
        }
        

        
        // Funci√≥n para recargar todo completamente
        function reloadEverything() {
            console.log('üîÑ Iniciando recarga completa del sistema...');
            
            // Deshabilitar enlaces durante la recarga
            const updateLink = document.querySelector('a[onclick*="updateArrivalTime"]');
            const reloadLink = document.querySelector('a[onclick*="reloadEverything"]');
            if (updateLink) updateLink.style.pointerEvents = 'none';
            if (reloadLink) reloadLink.style.pointerEvents = 'none';
            
            // Mostrar mensaje de recarga
            const arrivalsList = document.getElementById('arrivalsList');
            if (arrivalsList) {
                arrivalsList.innerHTML = `
                    <div class="loading">
                        <div style="text-align: center; padding: 40px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">üîÑ</div>
                            <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Recargando todo...</div>
                            <div style="font-size: 14px; color: #999;">Limpiando cach√© y recargando datos</div>
                        </div>
                    </div>
                `;
            }
            
            // 1. Limpiar cach√© del Service Worker
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                console.log('üßπ Limpiando cach√© del Service Worker...');
                navigator.serviceWorker.controller.postMessage({
                    type: 'CLEAR_CACHE',
                    cacheType: 'all' // Limpiar todos los cach√©s del SW
                });
            }
            
            // 2. Limpiar cach√© localStorage
            console.log('üßπ Limpiando cach√© localStorage...');
            clearCache(); // Nuestra funci√≥n personalizada
            
            // 3. Limpiar cach√© de JavaScript
            console.log('üßπ Limpiando cach√© de JavaScript...');
            linesData = {};
            stopsData = {};
            
            // 3. Limpiar mapa
            if (routeLayer) {
                routeLayer.clearLayers();
            }
            
            // 4. Limpiar todas las secciones
            const stopsList = document.getElementById('stopsList');
            const scheduleInfo = document.getElementById('scheduleInfo');
            
            if (stopsList) stopsList.innerHTML = `
                <li class="loading">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 20px; margin-bottom: 8px;">üìç</div>
                        <div style="font-size: 16px; color: #666;">Recargando paradas...</div>
                    </div>
                </li>
            `;
            
            if (scheduleInfo) scheduleInfo.innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">‚è≥</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Recargando horarios...</div>
                        <div style="font-size: 14px; color: #999;">Obteniendo informaci√≥n actualizada</div>
                    </div>
                </div>
            `;
            
            // 5. Recargar todo con delay para asegurar que la cach√© se limpie
            setTimeout(async () => {
                try {
                    console.log('üì° Recargando configuraci√≥n de rutas...');
                    await loadRoutesConfig(true);
                    
                    console.log('üì° Recargando datos generales...');
                    await getGeneralData();
                    
                    console.log('üìÖ Recargando horarios...');
                    getScheduleData();
                    
                    console.log('‚è±Ô∏è Recargando tiempos de llegada...');
                    getArrivalTime();
                    
                    console.log('‚úÖ Recarga completa finalizada');
                    
                } catch (error) {
                    console.error('‚ùå Error durante la recarga:', error);
                    
                    // Mostrar mensaje de error m√°s espec√≠fico
                    const scheduleInfo = document.getElementById('scheduleInfo');
                    if (scheduleInfo) {
                        scheduleInfo.innerHTML = `
                            <div class="error">
                                <div style="text-align: center; padding: 20px;">
                                    <div style="font-size: 24px; margin-bottom: 10px;">üîÑ</div>
                                    <div style="font-size: 16px; color: #c62828; margin-bottom: 10px;">Error durante la recarga</div>
                                    <div style="font-size: 14px; color: #666; margin-bottom: 8px;">Intentando recarga completa de p√°gina...</div>
                                    <div style="font-size: 12px; color: #999;">Esto puede tardar unos segundos</div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Si hay error, intentar recarga completa de p√°gina despu√©s de mostrar el mensaje
                    setTimeout(() => {
                        console.log('üîÑ Intentando recarga completa de p√°gina...');
                        window.location.reload(true);
                    }, 2000);
                } finally {
                    // Rehabilitar enlaces despu√©s de la recarga
                    setTimeout(() => {
                        if (updateLink) updateLink.style.pointerEvents = 'auto';
                        if (reloadLink) reloadLink.style.pointerEvents = 'auto';
                    }, 2000);
                }
            }, 1000);
        }
        
        // Actualizar solo la hora de √∫ltima actualizaci√≥n
        function updateTimeStamp() {
            const updateTime = document.getElementById('updateTime');
            const now = new Date();
            updateTime.innerHTML = `
                <div style="text-align: center; padding: 8px; font-size: 14px; color: #666;">
                    <span style="color: #2196F3; margin-right: 5px;">üïê</span>
                    <span style="font-weight: bold; color: #1976D2;">√öltima actualizaci√≥n:</span>
                    <span style="font-weight: bold; color: #333; margin: 0 5px;">
                        ${now.toLocaleTimeString('es-ES', {hour: '2-digit', minute: '2-digit'})}
                    </span>
                    <span style="color: #999;">
                        ${now.toLocaleDateString('es-ES', {day: '2-digit', month: '2-digit', year: 'numeric'})}
                    </span>
                </div>
            `;
        }
        
        // Actualizar horarios pr√≥ximos bas√°ndose en la hora actual
        function updateProximosHorarios() {
            try {
                const scheduleInfo = document.getElementById('scheduleInfo');
                if (!scheduleInfo || !scheduleInfo.innerHTML.includes('schedule-cards')) {
                    return; // No hay tarjetas de horarios visibles
                }
                
                // Buscar los datos de horarios almacenados globalmente
                if (!window.lastScheduleData || !window.lastScheduleData.servicios || window.lastScheduleData.servicios.length === 0) {
                    return; // No hay datos de horarios disponibles
                }
                
                const servicio = window.lastScheduleData.servicios[0];
                const esIda = currentRoute.originStop === 42;
                const horarios = esIda ? servicio.ida : servicio.vuelta;
                
                if (!horarios || horarios.length === 0) return;
                
                // Convertir formato HHMM a formato HH:MM
                function formatoHHMMToHora(hhmm) {
                    const horas = Math.floor(hhmm / 100);
                    const mins = hhmm % 100;
                    return `${horas.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;
                }
                
                // Calcular horarios pr√≥ximos bas√°ndose en la hora actual
                const ahora = new Date();
                const horaActual = ahora.getHours() * 60 + ahora.getMinutes();
                
                // Filtrar horarios pr√≥ximos: √∫ltima ya pasada y 4 siguientes
                const horariosProximos = [];
                let ultimaPasada = null;
                
                for (let i = 0; i < horarios.length; i++) {
                    const horaHorario = Math.floor(horarios[i] / 100);
                    const minHorario = horarios[i] % 100;
                    const minutosHorario = horaHorario * 60 + minHorario;
                    
                    // Si es la √∫ltima llegada ya pasada (pero no del d√≠a anterior)
                    if (minutosHorario <= horaActual && minutosHorario > horaActual - 60) {
                        ultimaPasada = formatoHHMMToHora(horarios[i]);
                    }
                    // Si es una llegada futura
                    else if (minutosHorario > horaActual) {
                        horariosProximos.push(formatoHHMMToHora(horarios[i]));
                        if (horariosProximos.length >= 4) break;
                    }
                }
                
                // Preparar informaci√≥n de horarios pr√≥ximos
                let proximosHorarios = '';
                if (ultimaPasada || horariosProximos.length > 0) {
                    const horariosTexto = [];
                    if (ultimaPasada) {
                        horariosTexto.push(`<span style="color: #666; text-decoration: line-through;">${ultimaPasada}</span>`);
                    }
                    horariosProximos.forEach(horario => {
                        horariosTexto.push(`<span style="color: #4CAF50; font-weight: bold;">${horario}</span>`);
                    });
                    if (horariosProximos.length === 4) {
                        horariosTexto.push('<span style="color: #999;">...</span>');
                    }
                    proximosHorarios = horariosTexto.join(' ‚Üí ');
                } else {
                    proximosHorarios = '<span style="color: #999;">No hay horarios pr√≥ximos</span>';
                }
                
                // Actualizar solo la secci√≥n de horarios pr√≥ximos en las tarjetas
                const proximosHorariosSpan = scheduleInfo.querySelector('.schedule-card-value');
                if (proximosHorariosSpan && proximosHorariosSpan.textContent.includes('Pr√≥ximas salidas')) {
                    proximosHorariosSpan.innerHTML = proximosHorarios;
                }
            } catch (error) {
                console.warn('Error actualizando horarios pr√≥ximos:', error);
                // No mostrar error al usuario, solo log
            }
        }
        
        // Mostrar estad√≠sticas de cach√©
        async function showCacheStats() {
            console.log('üìä Mostrando estad√≠sticas de cach√©...');
            
            const arrivalsList = document.getElementById('arrivalsList');
            
            // Mostrar mensaje de carga
            arrivalsList.innerHTML = `
                <div class="loading">
                    <div style="text-align: center; padding: 40px;">
                        <div style="font-size: 24px; margin-bottom: 10px;">üìä</div>
                        <div style="font-size: 18px; color: #666; margin-bottom: 10px;">Calculando estad√≠sticas...</div>
                        <div style="font-size: 14px; color: #999;">Analizando cach√© del sistema</div>
                    </div>
                </div>
            `;
            
            try {
                // Obtener estad√≠sticas localStorage
                let localStorageSize = 0;
                let localStorageCount = 0;
                const localStorageData = {};
                
                Object.keys(localStorage).forEach(key => {
                    if (key.includes('busCoruna')) {
                        const value = localStorage.getItem(key);
                        localStorageSize += value.length;
                        localStorageCount++;
                        
                        try {
                            const parsed = JSON.parse(value);
                            const age = Date.now() - parsed.timestamp;
                            const ageMinutes = Math.round(age / 1000 / 60);
                            const ageHours = Math.round(age / 1000 / 60 / 60);
                            const ageDays = Math.round(age / 1000 / 60 / 60 / 24);
                            
                            let ageText = `${ageMinutes} min`;
                            if (ageHours >= 1) ageText = `${ageHours} h`;
                            if (ageDays >= 1) ageText = `${ageDays} d`;
                            
                            let typeText = 'Desconocido';
                            if (key.includes('generalData')) typeText = 'Datos generales (7d)';
                            else if (key.includes('lineData')) typeText = 'Datos de l√≠nea (7d)';
                            else if (key.includes('scheduleData')) typeText = 'Horarios (1d)';
                            
                            localStorageData[key] = {
                                type: typeText,
                                size: Math.round(value.length / 1024 * 10) / 10,
                                age: ageText,
                                valid: age < parsed.ttl
                            };
                        } catch (e) {
                            localStorageData[key] = {
                                type: 'Error',
                                size: Math.round(value.length / 1024 * 10) / 10,
                                age: 'N/A',
                                valid: false
                            };
                        }
                    }
                });
                
                // Obtener estad√≠sticas Service Worker
                let swStats = null;
                if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                    const messageChannel = new MessageChannel();
                    navigator.serviceWorker.controller.postMessage({
                        type: 'CACHE_STATS'
                    }, [messageChannel.port2]);
                    
                    try {
                        swStats = await new Promise((resolve) => {
                            messageChannel.port1.onmessage = (event) => {
                                if (event.data.type === 'CACHE_STATS') {
                                    resolve(event.data.stats);
                                }
                            };
                            // Timeout despu√©s de 2 segundos
                            setTimeout(() => resolve(null), 2000);
                        });
                    } catch (e) {
                        console.warn('Error obteniendo stats del SW:', e);
                    }
                }
                
                // Construir HTML de estad√≠sticas
                let statsHtml = `
                    <div style="padding: 20px; text-align: left;">
                        <div style="text-align: center; margin-bottom: 20px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">üìä</div>
                            <div style="font-size: 18px; font-weight: bold; color: #1976D2;">Estad√≠sticas de Cach√©</div>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <h3 style="color: #2196F3; margin-bottom: 10px;">üíæ localStorage</h3>
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                                <strong>Total:</strong> ${localStorageCount} elementos, ${Math.round(localStorageSize/1024*10)/10} KB
                            </div>
                `;
                
                Object.entries(localStorageData).forEach(([key, data]) => {
                    const keyDisplay = key.replace('busCoruna_', '').replace('_', ' ');
                    const statusIcon = data.valid ? '‚úÖ' : '‚è∞';
                    statsHtml += `
                        <div style="background: #f9f9f9; padding: 8px; border-radius: 3px; margin: 5px 0; font-size: 12px;">
                            <div><strong>${statusIcon} ${keyDisplay}</strong></div>
                            <div style="color: #666;">Tipo: ${data.type}</div>
                            <div style="color: #666;">Tama√±o: ${data.size} KB | Edad: ${data.age}</div>
                        </div>
                    `;
                });
                
                if (swStats) {
                    statsHtml += `
                        <div style="margin-top: 20px;">
                            <h3 style="color: #2196F3; margin-bottom: 10px;">üîß Service Worker</h3>
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 5px;">
                                <div><strong>Est√°tico:</strong> ${swStats.static.count} elementos, ${Math.round(swStats.static.size/1024*10)/10} KB</div>
                                <div><strong>Diario:</strong> ${swStats.daily.count} elementos, ${Math.round(swStats.daily.size/1024*10)/10} KB</div>
                                <div><strong>Tiempo real:</strong> ${swStats.realtime.count} elementos, ${Math.round(swStats.realtime.size/1024*10)/10} KB</div>
                                <div style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #ddd;"><strong>Total SW:</strong> ${swStats.total.count} elementos, ${Math.round(swStats.total.size/1024*10)/10} KB</div>
                            </div>
                        </div>
                    `;
                } else {
                    statsHtml += `
                        <div style="margin-top: 20px;">
                            <h3 style="color: #FF9800; margin-bottom: 10px;">‚ö†Ô∏è Service Worker</h3>
                            <div style="background: #fff3e0; padding: 10px; border-radius: 5px; color: #f57c00;">
                                No se pudieron obtener estad√≠sticas del Service Worker
                            </div>
                        </div>
                    `;
                }
                
                statsHtml += `
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="getArrivalTime(); return false;" style="background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">
                            Volver a datos de llegada
                        </button>
                    </div>
                </div>
                `;
                
                arrivalsList.innerHTML = statsHtml;
                
            } catch (error) {
                console.error('Error mostrando estad√≠sticas:', error);
                arrivalsList.innerHTML = `
                    <div class="error">
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 24px; margin-bottom: 10px;">‚ùå</div>
                            <div style="font-size: 16px; color: #c62828;">Error obteniendo estad√≠sticas</div>
                            <div style="font-size: 12px; color: #999; margin-top: 10px;">${error.message}</div>
                        </div>
                    </div>
                `;
            }
        }
        
        // Inicializar aplicaci√≥n
        async function init() {
            console.log('Iniciando aplicaci√≥n Bus Coru√±a...');
            
            // Cargar preferencia de detecci√≥n autom√°tica
            try {
                const savedAutoDirection = localStorage.getItem('busCoruna_autoDirection');
                if (savedAutoDirection !== null) {
                    autoDirectionEnabled = savedAutoDirection === 'true';
                    const toggle = document.getElementById('autoDirectionToggle');
                    if (toggle) {
                        if (autoDirectionEnabled) {
                            toggle.textContent = 'üìç Auto: ON';
                            toggle.style.color = '';
                        } else {
                            toggle.textContent = 'üìç Auto: OFF';
                            toggle.style.color = '#999';
                        }
                    }
                }
            } catch (error) {
                console.warn('No se pudo cargar preferencia de detecci√≥n autom√°tica');
            }
            

            
            // Cargar configuraci√≥n de rutas primero
            await loadRoutesConfig();
            
            initMap();
            await getGeneralData();
            
            // Actualizar icono de GPS inicial
            updateGPSIcon();
            
            // Intentar detectar direcci√≥n autom√°ticamente despu√©s de cargar datos (sin mostrar notificaci√≥n)
            setTimeout(() => {
                detectAutoDirectionSilent().catch(error => {
                    console.log('‚ö†Ô∏è Detecci√≥n autom√°tica no disponible:', error.message);
                });
            }, 1000); // Peque√±o delay para asegurar que los datos est√©n procesados
            
            getScheduleData();
            getArrivalTime();
            
            // Refresco autom√°tico: actualizar solo la secci√≥n de "Pr√≥ximos buses" cada 2 minutos
            // Esto mantiene los tiempos de llegada actualizados sin afectar otras secciones
            setInterval(async () => {
                try {
                    await getArrivalTime();
                } catch (error) {
                    console.warn('Error en refresco autom√°tico de llegadas:', error);
                    // No mostrar error, solo reintentar en el siguiente ciclo
                }
            }, 120000);
            
            // Actualizar horarios cada d√≠a a las 00:00
            const now = new Date();
            const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
            const timeUntilMidnight = tomorrow - now;
            
            setTimeout(() => {
                getScheduleData();
                // Luego actualizar cada d√≠a
                setInterval(getScheduleData, 24 * 60 * 60 * 1000);
            }, timeUntilMidnight);
            
            // Actualizar solo la hora cada minuto
            setInterval(updateTimeStamp, 60000);
            
            // Actualizar horarios pr√≥ximos cada minuto (solo si hay datos disponibles)
            setInterval(() => {
                try {
                    updateProximosHorarios();
                } catch (error) {
                    console.warn('Error en actualizaci√≥n de horarios pr√≥ximos:', error);
                    // No mostrar error, solo continuar
                }
            }, 60000);
            
            console.log('Aplicaci√≥n iniciada correctamente');
        }
        
        // Registrar Service Worker para PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('Service Worker registrado'))
                    .catch(err => console.log('Service Worker error:', err));
            });
        }
        
        // Iniciar cuando el DOM est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Determinar si dos rutas comparten trayecto entre origen y destino
        function routesSharePath(route1, route2, originStop, destinationStop) {
            console.log('üîç Comparando rutas para determinar si comparten trayecto...');
            
            if (!route1.paradas || !route2.paradas) {
                console.log('‚ö†Ô∏è Una o ambas rutas no tienen paradas definidas');
                return false;
            }
            
            // Encontrar √≠ndices de origen y destino en ambas rutas
            const getRouteSegment = (route, origin, destination) => {
                const stopIds = route.paradas;
                let startIndex = -1;
                let endIndex = -1;
                
                for (let i = 0; i < stopIds.length; i++) {
                    if (stopIds[i] === origin) {
                        startIndex = i;
                    }
                    if (stopIds[i] === destination) {
                        endIndex = i;
                    }
                }
                
                // Verificar que ambos puntos est√©n en la ruta
                if (startIndex !== -1 && endIndex !== -1) {
                    // Asegurar que siempre devolvemos el segmento en orden ascendente para comparaci√≥n
                    const actualStart = Math.min(startIndex, endIndex);
                    const actualEnd = Math.max(startIndex, endIndex);
                    return stopIds.slice(actualStart, actualEnd + 1);
                }
                return null;
            };
            
            const segment1 = getRouteSegment(route1, originStop, destinationStop);
            const segment2 = getRouteSegment(route2, originStop, destinationStop);
            
            if (!segment1 || !segment2) {
                console.log('‚ö†Ô∏è No se pudo obtener segmento de una o ambas rutas');
                return false;
            }
            
            console.log('üìç Segmento ruta 1:', segment1);
            console.log('üìç Segmento ruta 2:', segment2);
            
            // Comparar si los segmentos son id√©nticos
            if (segment1.length !== segment2.length) {
                console.log('üìè Los segmentos tienen diferentes longitudes, no comparten trayecto');
                return false;
            }
            
            for (let i = 0; i < segment1.length; i++) {
                if (segment1[i] !== segment2[i]) {
                    console.log('‚ùå Los segmentos difieren en la parada', i, ':', segment1[i], 'vs', segment2[i]);
                    return false;
                }
            }
            
            console.log('‚úÖ Las rutas comparten el mismo trayecto');
            return true;
        }
    </script>
</body>
</html>