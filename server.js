const express = require('express');
const cors = require('cors');
const axios = require('axios');
const path = require('path');
const NodeCache = require('node-cache');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 10000;

// Configurar cach√© en memoria
const cache = new NodeCache({
    stdTTL: 600, // TTL por defecto: 10 minutos
    checkperiod: 120 // Verificar elementos expirados cada 2 minutos
});

// Configuraci√≥n de URLs base de la API
const BASE_API_URL = 'https://itranvias.com/queryitr_v3.php';

// Configurar CORS para permitir peticiones desde el frontend
app.use(cors({
    origin: ['http://localhost:8000', 'http://127.0.0.1:8000', 'http://localhost:10000'],
    credentials: true
}));

// Middleware para parsear JSON
app.use(express.json());

// Configurar headers para evitar problemas de CORS
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
    next();
});

// Servir archivos est√°ticos desde la ra√≠z
app.use(express.static(path.join(__dirname)));

// === FUNCIONES DE UTILIDAD PARA CACH√â ===

/**
 * Realiza una petici√≥n HTTP con cach√© inteligente
 * @param {string} cacheKey - Clave √∫nica para el cach√©
 * @param {string} url - URL completa de la API
 * @param {number} ttl - Time To Live en segundos
 * @param {string} logCategory - Categor√≠a para los logs
 * @param {Object} extraData - Datos adicionales para logs
 */
async function cachedApiRequest(cacheKey, url, ttl, logCategory, extraData = {}) {
    // Verificar cach√© primero
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
        console.log(`‚úÖ [${logCategory}] Datos servidos desde cach√©:`);
        console.log(`   üóÉÔ∏è  Cache Key: ${cacheKey}`);
        console.log(`   üì¶ Tama√±o: ${JSON.stringify(cachedData).length} bytes`);
        Object.entries(extraData).forEach(([key, value]) => {
            console.log(`   ${key}: ${value}`);
        });
        return { data: cachedData, fromCache: true };
    }

    try {
        console.log(`üöå [${logCategory}] Petici√≥n a API remota (cach√© miss):`);
        console.log(`   üîó URL: ${url}`);
        console.log(`   üóÉÔ∏è  Cache Key: ${cacheKey}`);
        console.log(`   ‚è∞ TTL: ${ttl}s`);
        Object.entries(extraData).forEach(([key, value]) => {
            console.log(`   ${key}: ${value}`);
        });

        const startTime = Date.now();
        const response = await axios.get(url, {
            timeout: 15000,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
        });
        const endTime = Date.now();
        const responseTime = endTime - startTime;

        // Guardar en cach√©
        cache.set(cacheKey, response.data, ttl);

        console.log(`‚úÖ [${logCategory}] Respuesta exitosa y cacheada:`);
        console.log(`   üìä Status: ${response.status}`);
        console.log(`   ‚è±Ô∏è  Tiempo de respuesta: ${responseTime}ms`);
        console.log(`   üì¶ Tama√±o: ${JSON.stringify(response.data).length} bytes`);
        console.log(`   üóÉÔ∏è  Guardado en cach√© por ${ttl}s`);

        return { data: response.data, fromCache: false };

    } catch (error) {
        console.error(`‚ùå [${logCategory}] Error en petici√≥n:`);
        console.error(`   üîó URL: ${url}`);
        console.error(`   üóÉÔ∏è  Cache Key: ${cacheKey}`);
        console.error(`   ‚ö†Ô∏è  Error: ${error.message}`);
        if (error.response) {
            console.error(`   üìä Status: ${error.response.status}`);
        }
        throw error;
    }
}

/**
 * Obtiene datos generales desde cach√© o API
 */
async function getGeneralData() {
    const cacheKey = 'generalData';
    const url = `${BASE_API_URL}?dato=20160101T000000_es_0_20160101T000000&func=7`;
    const ttl = 24 * 3600; // 24 horas

    return await cachedApiRequest(cacheKey, url, ttl, 'GENERAL');
}

/**
 * Calcula TTL hasta la medianoche para horarios
 */
function getTTLUntilMidnight() {
    const now = new Date();
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0); // Pr√≥xima medianoche
    return Math.floor((midnight - now) / 1000);
}

// Ruta principal
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Ruta para la configuraci√≥n de rutas
app.get('/routes.json', (req, res) => {
    res.sendFile(path.join(__dirname, 'routes.json'));
});

// API routes - prefijo /buscoruna/api
app.use('/buscoruna/api', (req, res, next) => {
    // Remover el prefijo /buscoruna/api para las rutas internas
    req.url = req.url.replace('/buscoruna/api', '');
    next();
});

// Tiempos de llegada con cach√© breve optimizado
app.get('/api/arrivals/:stopId', async (req, res) => {
    try {
        const { stopId } = req.params;
        
        // Debug: mostrar el valor recibido
        console.log(`üîç [ARRIVALS DEBUG] stopId recibido: "${stopId}" (tipo: ${typeof stopId})`);
        
        // Validar que stopId no sea undefined, null o 'undefined'
        if (!stopId || stopId === 'undefined' || stopId === 'null') {
            console.error(`‚ùå [ARRIVALS] Par√°metro stopId inv√°lido: "${stopId}"`);
            return res.status(400).json({
                error: 'Par√°metro stopId requerido',
                message: `El par√°metro stopId debe ser un n√∫mero v√°lido, recibido: "${stopId}"`
            });
        }
        
        const cacheKey = `arrivals_${stopId}`;
        const url = `${BASE_API_URL}?func=0&dato=${stopId}`;
        const ttl = 15; // 15 segundos para datos en tiempo real
        
        const result = await cachedApiRequest(
            cacheKey, 
            url, 
            ttl, 
            'ARRIVALS', 
            { 'üìç Parada': stopId }
        );
        
        // Headers para datos en tiempo real
        res.set({
            'Cache-Control': 'public, max-age=15', // 15 segundos
            'X-Cache-Type': 'realtime-15s',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error(`‚ùå [ARRIVALS] Error para parada ${req.params.stopId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener tiempos de llegada',
            message: error.message
        });
    }
});

// === ENDPOINTS OPTIMIZADOS ===

// Datos generales con cach√© optimizado (l√≠neas, paradas, tarifas)
app.get('/api/general', async (req, res) => {
    try {
        const result = await getGeneralData();
        
        // Headers para datos est√°ticos
        res.set({
            'Cache-Control': 'public, max-age=86400', // 24 horas
            'X-Cache-Type': 'static-24h',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error('‚ùå [GENERAL] Error obteniendo datos generales:', error.message);
        res.status(500).json({
            error: 'Error al obtener datos generales',
            message: error.message
        });
    }
});

// Datos espec√≠ficos de l√≠nea optimizado (reutiliza datos generales cacheados)
app.get('/api/line/:lineId', async (req, res) => {
    try {
        const { lineId } = req.params;
        
        // Validar que lineId no sea undefined, null o 'undefined'
        if (!lineId || lineId === 'undefined' || lineId === 'null') {
            console.error(`‚ùå [LINE] Par√°metro lineId inv√°lido: "${lineId}"`);
            return res.status(400).json({
                error: 'Par√°metro lineId requerido',
                message: `El par√°metro lineId debe ser un n√∫mero v√°lido, recibido: "${lineId}"`
            });
        }
        
        // Primero intentar obtener datos est√°ticos del cach√© general
        let staticLineData = null;
        try {
            const generalResult = await getGeneralData();
            if (generalResult.data && generalResult.data.lineas) {
                staticLineData = generalResult.data.lineas.find(line => line.id === lineId);
            }
        } catch (err) {
            console.log(`‚ö†Ô∏è  [LINE] No se pudieron obtener datos generales, consultando API directa`);
        }
        
        // Si no encontramos la l√≠nea en cach√© general, consultar API espec√≠fica
        if (!staticLineData) {
            const cacheKey = `line_${lineId}`;
            const url = `${BASE_API_URL}?func=1&dato=${lineId}`;
            const ttl = 24 * 3600; // 24 horas para datos est√°ticos
            
            const result = await cachedApiRequest(
                cacheKey, 
                url, 
                ttl, 
                'LINE', 
                { 'üöá L√≠nea': lineId }
            );
            
            res.set({
                'Cache-Control': 'public, max-age=86400', // 24 horas
                'X-Cache-Type': 'static-24h',
                'X-Cache-Hit': result.fromCache ? 'true' : 'false',
                'X-Data-Source': 'api-specific',
                'Access-Control-Allow-Origin': '*'
            });
            
            return res.json(result.data);
        }
        
        // Datos encontrados en cach√© general
        console.log(`‚úÖ [LINE] Datos est√°ticos servidos desde cach√© general:`);
        console.log(`   üöá L√≠nea: ${lineId}`);
        console.log(`   üì¶ Datos: ${staticLineData.nom_comer} (${staticLineData.orig_linea} - ${staticLineData.dest_linea})`);
        
        res.set({
            'Cache-Control': 'public, max-age=86400', // 24 horas
            'X-Cache-Type': 'static-24h',
            'X-Cache-Hit': 'true',
            'X-Data-Source': 'general-cache',
            'Access-Control-Allow-Origin': '*'
        });
        
        // Formato compatible con la respuesta original
        res.json({
            resultado: "OK",
            fecha_peticion: new Date().toISOString().replace(/[-:T]/g, '').slice(0, 14),
            lineas: [staticLineData],
            Origen: "Cache_Optimizado"
        });
        
    } catch (error) {
        console.error(`‚ùå [LINE] Error para l√≠nea ${req.params.lineId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener datos de l√≠nea',
            message: error.message
        });
    }
});

// Horarios de l√≠nea optimizado (cach√© hasta medianoche)
app.get('/api/schedule/:lineId/:fecha', async (req, res) => {
    try {
        const { lineId, fecha } = req.params;
        
        // Validar que los par√°metros no sean undefined, null o 'undefined'
        if (!lineId || lineId === 'undefined' || lineId === 'null') {
            console.error(`‚ùå [SCHEDULE] Par√°metro lineId inv√°lido: "${lineId}"`);
            return res.status(400).json({
                error: 'Par√°metro lineId requerido',
                message: `El par√°metro lineId debe ser un n√∫mero v√°lido, recibido: "${lineId}"`
            });
        }
        
        if (!fecha || fecha === 'undefined' || fecha === 'null') {
            console.error(`‚ùå [SCHEDULE] Par√°metro fecha inv√°lido: "${fecha}"`);
            return res.status(400).json({
                error: 'Par√°metro fecha requerido',
                message: `El par√°metro fecha debe tener formato YYYYMMDD, recibido: "${fecha}"`
            });
        }
        
        const cacheKey = `schedule_${lineId}_${fecha}`;
        const url = `${BASE_API_URL}?func=8&dato=${lineId}&fecha=${fecha}`;
        
        // TTL hasta medianoche para la fecha consultada
        const ttl = getTTLUntilMidnight();
        
        const result = await cachedApiRequest(
            cacheKey, 
            url, 
            ttl, 
            'SCHEDULE', 
            { 'üöá L√≠nea': lineId, 'üìÖ Fecha': fecha }
        );
        
        // Headers para horarios
        res.set({
            'Cache-Control': `public, max-age=${ttl}`,
            'X-Cache-Type': 'until-midnight',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error(`‚ùå [SCHEDULE] Error para l√≠nea ${req.params.lineId}, fecha ${req.params.fecha}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener horarios',
            message: error.message
        });
    }
});

// === NUEVOS ENDPOINTS PARA APROVECHAR LA API COMPLETA ===

// Posiciones de buses en una l√≠nea (datos en tiempo real)
app.get('/api/line/:lineId/buses', async (req, res) => {
    try {
        const { lineId } = req.params;
        const cacheKey = `buses_${lineId}`;
        const url = `${BASE_API_URL}?func=2&dato=${lineId}`;
        const ttl = 15; // 15 segundos para posiciones de buses
        
        const result = await cachedApiRequest(
            cacheKey, 
            url, 
            ttl, 
            'BUSES-POSITION', 
            { 'üöá L√≠nea': lineId }
        );
        
        res.set({
            'Cache-Control': 'public, max-age=15',
            'X-Cache-Type': 'realtime-15s',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error(`‚ùå [BUSES-POSITION] Error para l√≠nea ${req.params.lineId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener posiciones de buses',
            message: error.message
        });
    }
});

// Coordenadas geogr√°ficas de buses de una l√≠nea
app.get('/api/line/:lineId/buses/coordinates', async (req, res) => {
    try {
        const { lineId } = req.params;
        const cacheKey = `bus_coords_${lineId}`;
        const url = `${BASE_API_URL}?func=99&mostrar=B&dato=${lineId}`;
        const ttl = 15; // 15 segundos para coordenadas de buses
        
        const result = await cachedApiRequest(
            cacheKey, 
            url, 
            ttl, 
            'BUS-COORDINATES', 
            { 'üöá L√≠nea': lineId }
        );
        
        res.set({
            'Cache-Control': 'public, max-age=15',
            'X-Cache-Type': 'realtime-15s',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error(`‚ùå [BUS-COORDINATES] Error para l√≠nea ${req.params.lineId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener coordenadas de buses',
            message: error.message
        });
    }
});

// Coordenadas de paradas de una l√≠nea
app.get('/api/line/:lineId/stops/coordinates', async (req, res) => {
    try {
        const { lineId } = req.params;
        const cacheKey = `stop_coords_${lineId}`;
        const url = `${BASE_API_URL}?func=99&mostrar=P&dato=${lineId}`;
        const ttl = 7 * 24 * 3600; // 7 d√≠as para coordenadas de paradas (datos est√°ticos)
        
        const result = await cachedApiRequest(
            cacheKey, 
            url, 
            ttl, 
            'STOP-COORDINATES', 
            { 'üöá L√≠nea': lineId }
        );
        
        res.set({
            'Cache-Control': 'public, max-age=604800', // 7 d√≠as
            'X-Cache-Type': 'static-7d',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error(`‚ùå [STOP-COORDINATES] Error para l√≠nea ${req.params.lineId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener coordenadas de paradas',
            message: error.message
        });
    }
});

// Trazado del recorrido de una l√≠nea (polil√≠nea)
app.get('/api/line/:lineId/route', async (req, res) => {
    try {
        const { lineId } = req.params;
        const cacheKey = `route_${lineId}`;
        const url = `${BASE_API_URL}?func=99&mostrar=R&dato=${lineId}`;
        const ttl = 7 * 24 * 3600; // 7 d√≠as para trazado de recorrido (datos est√°ticos)
        
        const result = await cachedApiRequest(
            cacheKey, 
            url, 
            ttl, 
            'ROUTE-TRACE', 
            { 'üöá L√≠nea': lineId }
        );
        
        res.set({
            'Cache-Control': 'public, max-age=604800', // 7 d√≠as
            'X-Cache-Type': 'static-7d',
            'X-Cache-Hit': result.fromCache ? 'true' : 'false',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(result.data);
        
    } catch (error) {
        console.error(`‚ùå [ROUTE-TRACE] Error para l√≠nea ${req.params.lineId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener trazado de recorrido',
            message: error.message
        });
    }
});

// Endpoint consolidado para datos completos de una l√≠nea
app.get('/api/line/:lineId/complete', async (req, res) => {
    try {
        const { lineId } = req.params;
        
        // Ejecutar m√∫ltiples peticiones en paralelo para optimizar
        const [
            staticDataResult,
            busPositionsResult,
            busCoordinatesResult
        ] = await Promise.allSettled([
            // Datos est√°ticos (desde cach√© general o API espec√≠fica)
            (async () => {
                try {
                    const generalResult = await getGeneralData();
                    if (generalResult.data && generalResult.data.lineas) {
                        const lineData = generalResult.data.lineas.find(line => line.id === lineId);
                        if (lineData) return { data: lineData, fromCache: true };
                    }
                } catch (err) {
                    console.log(`‚ö†Ô∏è  Fallback a API espec√≠fica para l√≠nea ${lineId}`);
                }
                
                const cacheKey = `line_${lineId}`;
                const url = `${BASE_API_URL}?func=1&dato=${lineId}`;
                return await cachedApiRequest(cacheKey, url, 24 * 3600, 'LINE-COMPLETE');
            })(),
            
            // Posiciones de buses
            cachedApiRequest(`buses_${lineId}`, `${BASE_API_URL}?func=2&dato=${lineId}`, 15, 'BUSES-COMPLETE'),
            
            // Coordenadas geogr√°ficas de buses
            cachedApiRequest(`bus_coords_${lineId}`, `${BASE_API_URL}?func=99&mostrar=B&dato=${lineId}`, 15, 'BUS-COORDS-COMPLETE')
        ]);
        
        // Consolidar resultados
        const response = {
            lineId,
            timestamp: new Date().toISOString(),
            static: staticDataResult.status === 'fulfilled' ? staticDataResult.value.data : null,
            buses: busPositionsResult.status === 'fulfilled' ? busPositionsResult.value.data : null,
            coordinates: busCoordinatesResult.status === 'fulfilled' ? busCoordinatesResult.value.data : null,
            cache_info: {
                static_cached: staticDataResult.status === 'fulfilled' && staticDataResult.value.fromCache,
                buses_cached: busPositionsResult.status === 'fulfilled' && busPositionsResult.value.fromCache,
                coordinates_cached: busCoordinatesResult.status === 'fulfilled' && busCoordinatesResult.value.fromCache
            }
        };
        
        console.log(`‚úÖ [LINE-COMPLETE] Datos consolidados para l√≠nea ${lineId}:`);
        console.log(`   üìä Datos est√°ticos: ${response.static ? '‚úì' : '‚úó'}`);
        console.log(`   üöå Posiciones buses: ${response.buses ? '‚úì' : '‚úó'}`);
        console.log(`   üìç Coordenadas: ${response.coordinates ? '‚úì' : '‚úó'}`);
        
        res.set({
            'Cache-Control': 'public, max-age=15', // TTL m√°s corto por datos din√°micos
            'X-Cache-Type': 'mixed',
            'Access-Control-Allow-Origin': '*'
        });
        
        res.json(response);
        
    } catch (error) {
        console.error(`‚ùå [LINE-COMPLETE] Error para l√≠nea ${req.params.lineId}:`, error.message);
        res.status(500).json({
            error: 'Error al obtener datos completos de l√≠nea',
            message: error.message
        });
    }
});

// Middleware para manejar errores
app.use((err, req, res, next) => {
    console.error('Error del servidor:', err.stack);
    res.status(500).json({
        error: 'Error interno del servidor',
        message: err.message
    });
});

// === INICIALIZACI√ìN DEL SERVIDOR ===

// Precargar datos generales al iniciar (opcional)
async function preloadGeneralData() {
    try {
        console.log('üîÑ Precargando datos generales...');
        await getGeneralData();
        console.log('‚úÖ Datos generales precargados en cach√©');
    } catch (error) {
        console.log('‚ö†Ô∏è  No se pudieron precargar datos generales:', error.message);
    }
}

// Iniciar servidor
app.listen(PORT, () => {
    console.log(`üöå Servidor BusCoru√±a optimizado iniciado en http://localhost:${PORT}`);
    console.log(`üì¶ Sistema de cach√©: node-cache habilitado`);
    console.log(`üì° Endpoints disponibles:`);
    console.log(`\n   === DATOS B√ÅSICOS ===`);
    console.log(`   - GET /api/general                          (L√≠neas, paradas, tarifas - Cache 24h)`);
    console.log(`   - GET /api/arrivals/:stopId                 (Llegadas a parada - Cache 15s)`);
    console.log(`\n   === INFORMACI√ìN DE L√çNEAS ===`);
    console.log(`   - GET /api/line/:lineId                     (Info l√≠nea - Reutiliza cache general)`);
    console.log(`   - GET /api/schedule/:lineId/:fecha          (Horarios - Cache hasta medianoche)`);
    console.log(`\n   === DATOS EN TIEMPO REAL ===`);
    console.log(`   - GET /api/line/:lineId/buses               (Posiciones buses - Cache 15s)`);
    console.log(`   - GET /api/line/:lineId/buses/coordinates   (Coordenadas buses - Cache 15s)`);
    console.log(`\n   === DATOS EST√ÅTICOS GEOGR√ÅFICOS ===`);
    console.log(`   - GET /api/line/:lineId/stops/coordinates   (Coordenadas paradas - Cache 7d)`);
    console.log(`   - GET /api/line/:lineId/route               (Trazado recorrido - Cache 7d)`);
    console.log(`\n   === ENDPOINT CONSOLIDADO ===`);
    console.log(`   - GET /api/line/:lineId/complete            (Todos los datos - Cache mixto)`);
    console.log(`\nüóÇÔ∏è  Estrategias de cach√© implementadas:`);
    console.log(`   üì¶ Datos est√°ticos: 24h (l√≠neas, paradas, tarifas)`);
    console.log(`   üèÉ Tiempo real: 15s (llegadas, posiciones buses)`);
    console.log(`   üìÖ Horarios: hasta medianoche`);
    console.log(`   üó∫Ô∏è  Geogr√°ficos: 7d (rutas, coordenadas paradas)`);
    console.log(`\n‚ö° Optimizaciones activas:`);
    console.log(`   üîÑ Reutilizaci√≥n de datos cacheados`);
    console.log(`   üöÄ Peticiones paralelas en endpoints consolidados`);
    console.log(`   üìä Headers informativos de cach√©`);
    
    // Precargar datos generales despu√©s de 2 segundos
    setTimeout(preloadGeneralData, 2000);
}); 